<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Workshop</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="overview.html">Overview</a></li><li><a href="intro/title.html"><strong aria-hidden="true">1.</strong> Introduction and Cargo</a></li><li><ol class="section"><li><a href="intro/what_is_rust.html"><strong aria-hidden="true">1.1.</strong> What is Rust Exactly?</a></li><li><a href="intro/the_type_system.html"><strong aria-hidden="true">1.2.</strong> The Type System</a></li><li><a href="intro/pillars_of_rust.html"><strong aria-hidden="true">1.3.</strong> Pillars of Rust</a></li><li><a href="intro/short_timeline.html"><strong aria-hidden="true">1.4.</strong> Short Timeline</a></li><li><a href="intro/tools.html"><strong aria-hidden="true">1.5.</strong> Tools</a></li><li><a href="intro/community.html"><strong aria-hidden="true">1.6.</strong> Community</a></li><li><a href="intro/domains.html"><strong aria-hidden="true">1.7.</strong> Domains</a></li><li><a href="intro/wisdom.html"><strong aria-hidden="true">1.8.</strong> Some Wisdom</a></li><li><a href="intro/getting_started.html"><strong aria-hidden="true">1.9.</strong> Getting Started</a></li><li><a href="intro/hello_world.html"><strong aria-hidden="true">1.10.</strong> Hello World</a></li><li><a href="intro/installing_rust.html"><strong aria-hidden="true">1.11.</strong> Installing Rust</a></li><li><a href="intro/rustup_1.html"><strong aria-hidden="true">1.12.</strong> Rustup 1</a></li><li><a href="intro/rustup_2.html"><strong aria-hidden="true">1.13.</strong> Rustup 2</a></li><li><a href="intro/rustup_3.html"><strong aria-hidden="true">1.14.</strong> Rustup 3</a></li><li><a href="intro/cargo.html"><strong aria-hidden="true">1.15.</strong> Cargo</a></li><li><a href="intro/cargo_new.html"><strong aria-hidden="true">1.16.</strong> Cargo New</a></li><li><a href="intro/new_crate.html"><strong aria-hidden="true">1.17.</strong> New Crate</a></li><li><a href="intro/cargo_toml.html"><strong aria-hidden="true">1.18.</strong> Cargo.toml</a></li><li><a href="intro/cargo_build.html"><strong aria-hidden="true">1.19.</strong> Cargo Build</a></li><li><a href="intro/cargo_lock.html"><strong aria-hidden="true">1.20.</strong> Cargo.lock</a></li><li><a href="intro/cargo_run.html"><strong aria-hidden="true">1.21.</strong> Cargo Run</a></li><li><a href="intro/cargo_run_release.html"><strong aria-hidden="true">1.22.</strong> Cargo Run Release</a></li></ol></li><li><a href="common_concepts/title.html"><strong aria-hidden="true">2.</strong> Common Programming Concepts</a></li><li><ol class="section"><li><a href="common_concepts/last_time.html"><strong aria-hidden="true">2.1.</strong> Last Time</a></li><li><a href="common_concepts/quote.html"><strong aria-hidden="true">2.2.</strong> Quote</a></li><li><a href="common_concepts/keywords.html"><strong aria-hidden="true">2.3.</strong> Keywords</a></li><li><a href="common_concepts/identifiers.html"><strong aria-hidden="true">2.4.</strong> Identifiers</a></li><li><a href="common_concepts/variables_1.html"><strong aria-hidden="true">2.5.</strong> Variables 1</a></li><li><a href="common_concepts/variables_2.html"><strong aria-hidden="true">2.6.</strong> Variables 2</a></li><li><a href="common_concepts/variables_3.html"><strong aria-hidden="true">2.7.</strong> Variables 3</a></li><li><a href="common_concepts/variable_shadowing.html"><strong aria-hidden="true">2.8.</strong> Variable Shadowing</a></li><li><a href="common_concepts/variable_and_types.html"><strong aria-hidden="true">2.9.</strong> Variables and Types</a></li><li><a href="common_concepts/data_types/title.html"><strong aria-hidden="true">2.10.</strong> Data Types</a></li><li><ol class="section"><li><a href="common_concepts/data_types/scalars.html"><strong aria-hidden="true">2.10.1.</strong> Scalars</a></li><li><a href="common_concepts/data_types/integer_literals.html"><strong aria-hidden="true">2.10.2.</strong> Integer Literals</a></li><li><a href="common_concepts/data_types/others.html"><strong aria-hidden="true">2.10.3.</strong> Others</a></li></ol></li><li><a href="common_concepts/type_annotations_1.html"><strong aria-hidden="true">2.11.</strong> Type Annotations 1</a></li><li><a href="common_concepts/type_annotations_2.html"><strong aria-hidden="true">2.12.</strong> Type Annotations 2</a></li><li><a href="common_concepts/type_annotations_3.html"><strong aria-hidden="true">2.13.</strong> Type Annotations 3</a></li><li><a href="common_concepts/numeric_casting_1.html"><strong aria-hidden="true">2.14.</strong> Numeric Casting 1</a></li><li><a href="common_concepts/numeric_casting_2.html"><strong aria-hidden="true">2.15.</strong> Numeric Casting 2</a></li><li><a href="common_concepts/clippy_example.html"><strong aria-hidden="true">2.16.</strong> Side Note: Clippy Example</a></li><li><a href="common_concepts/compound_types/title.html"><strong aria-hidden="true">2.17.</strong> Compound Types</a></li><li><ol class="section"><li><a href="common_concepts/compound_types/tuples.html"><strong aria-hidden="true">2.17.1.</strong> Tuples</a></li><li><a href="common_concepts/compound_types/arrays_1.html"><strong aria-hidden="true">2.17.2.</strong> Arrays 1</a></li><li><a href="common_concepts/compound_types/arrays_2.html"><strong aria-hidden="true">2.17.3.</strong> Arrays 2</a></li><li><a href="common_concepts/compound_types/arrays_3.html"><strong aria-hidden="true">2.17.4.</strong> Arrays 3</a></li></ol></li><li><a href="common_concepts/functions/title.html"><strong aria-hidden="true">2.18.</strong> Functions</a></li><li><ol class="section"><li><a href="common_concepts/functions/parameters.html"><strong aria-hidden="true">2.18.1.</strong> Parameters</a></li><li><a href="common_concepts/functions/definitions.html"><strong aria-hidden="true">2.18.2.</strong> Definitions</a></li><li><a href="common_concepts/functions/expressions_1.html"><strong aria-hidden="true">2.18.3.</strong> Expressions 1</a></li><li><a href="common_concepts/functions/expressions_2.html"><strong aria-hidden="true">2.18.4.</strong> Expressions 2</a></li><li><a href="common_concepts/functions/return_values.html"><strong aria-hidden="true">2.18.5.</strong> Return Values</a></li></ol></li><li><a href="common_concepts/comments.html"><strong aria-hidden="true">2.19.</strong> Comments</a></li><li><a href="common_concepts/control_flow/title.html"><strong aria-hidden="true">2.20.</strong> Control Flow</a></li><li><ol class="section"><li><a href="common_concepts/control_flow/if_and_else.html"><strong aria-hidden="true">2.20.1.</strong> If and Else</a></li><li><a href="common_concepts/control_flow/if_in_a_let_statement_1.html"><strong aria-hidden="true">2.20.2.</strong> If in a Let Statement 1</a></li><li><a href="common_concepts/control_flow/if_in_a_let_statement_2.html"><strong aria-hidden="true">2.20.3.</strong> If in a Let Statement 2</a></li><li><a href="common_concepts/control_flow/loops_1.html"><strong aria-hidden="true">2.20.4.</strong> Loops 1</a></li><li><a href="common_concepts/control_flow/loops_2.html"><strong aria-hidden="true">2.20.5.</strong> Loops 2</a></li><li><a href="common_concepts/control_flow/while_loops.html"><strong aria-hidden="true">2.20.6.</strong> While Loops</a></li><li><a href="common_concepts/control_flow/for_loops_1.html"><strong aria-hidden="true">2.20.7.</strong> For Loops 1</a></li><li><a href="common_concepts/control_flow/for_loops_2.html"><strong aria-hidden="true">2.20.8.</strong> For Loops 2</a></li></ol></li></ol></li><li><a href="ownership/title.html"><strong aria-hidden="true">3.</strong> Ownership</a></li><li><ol class="section"><li><a href="ownership/last_time.html"><strong aria-hidden="true">3.1.</strong> Last Time</a></li><li><a href="ownership/quote.html"><strong aria-hidden="true">3.2.</strong> Quote</a></li><li><a href="ownership/intro.html"><strong aria-hidden="true">3.3.</strong> Introduction</a></li><li><a href="ownership/stack_and_heap.html"><strong aria-hidden="true">3.4.</strong> Stack and Heap</a></li><li><a href="ownership/ownership_rules.html"><strong aria-hidden="true">3.5.</strong> Ownership Rules</a></li><li><a href="ownership/variable_scopes.html"><strong aria-hidden="true">3.6.</strong> Variable Scopes</a></li><li><a href="ownership/strings.html"><strong aria-hidden="true">3.7.</strong> Strings</a></li><li><a href="ownership/str_and_string.html"><strong aria-hidden="true">3.8.</strong> &amp;str and String</a></li><li><a href="ownership/a_heap_allocated_string.html"><strong aria-hidden="true">3.9.</strong> A Heap Allocated String</a></li><li><a href="ownership/raii.html"><strong aria-hidden="true">3.10.</strong> RAII</a></li><li><a href="ownership/interactions/title.html"><strong aria-hidden="true">3.11.</strong> Ways Variable and Data Interact</a></li><li><ol class="section"><li><a href="ownership/interactions/move_1.html"><strong aria-hidden="true">3.11.1.</strong> Ways Variable and Data Interact: Move 1</a></li><li><a href="ownership/interactions/move_2.html"><strong aria-hidden="true">3.11.2.</strong> Ways Variable and Data Interact: Move 2</a></li><li><a href="ownership/interactions/move_3.html"><strong aria-hidden="true">3.11.3.</strong> Ways Variable and Data Interact: Move 3</a></li><li><a href="ownership/interactions/move_4.html"><strong aria-hidden="true">3.11.4.</strong> Ways Variable and Data Interact: Move 4</a></li><li><a href="ownership/interactions/move_5.html"><strong aria-hidden="true">3.11.5.</strong> Ways Variable and Data Interact: Move 5</a></li><li><a href="ownership/interactions/move_6.html"><strong aria-hidden="true">3.11.6.</strong> Ways Variable and Data Interact: Move 6</a></li><li><a href="ownership/interactions/move_7.html"><strong aria-hidden="true">3.11.7.</strong> Ways Variable and Data Interact: Move 7</a></li><li><a href="ownership/interactions/move_8.html"><strong aria-hidden="true">3.11.8.</strong> Ways Variable and Data Interact: Move 8</a></li><li><a href="ownership/interactions/clone.html"><strong aria-hidden="true">3.11.9.</strong> Ways Variable and Data Interact: Clone</a></li></ol></li><li><a href="ownership/copy.html"><strong aria-hidden="true">3.12.</strong> Stack-Only Data: Copy</a></li><li><a href="ownership/other_copy_types.html"><strong aria-hidden="true">3.13.</strong> Other Copy Types</a></li><li><a href="ownership/ownership_and_functions.html"><strong aria-hidden="true">3.14.</strong> Ownership and Functions</a></li><li><a href="ownership/return_values_and_scope.html"><strong aria-hidden="true">3.15.</strong> Return Values and Scope</a></li><li><a href="ownership/references_and_borrowing_1.html"><strong aria-hidden="true">3.16.</strong> References and Borrowing 1</a></li><li><a href="ownership/references_and_borrowing_2.html"><strong aria-hidden="true">3.17.</strong> References and Borrowing 2</a></li><li><a href="ownership/references_and_borrowing_3.html"><strong aria-hidden="true">3.18.</strong> References and Borrowing 3</a></li><li><a href="ownership/references_and_borrowing_4.html"><strong aria-hidden="true">3.19.</strong> References and Borrowing 4</a></li><li><a href="ownership/mutable_references_1.html"><strong aria-hidden="true">3.20.</strong> Mutable References 1</a></li><li><a href="ownership/mutable_references_2.html"><strong aria-hidden="true">3.21.</strong> Mutable References 2</a></li><li><a href="ownership/mutable_references_3.html"><strong aria-hidden="true">3.22.</strong> Mutable References 3</a></li><li><a href="ownership/mutable_references_4.html"><strong aria-hidden="true">3.23.</strong> Mutable References 4</a></li><li><a href="ownership/mulitple_mutable_references.html"><strong aria-hidden="true">3.24.</strong> Mulitple Mutable References</a></li><li><a href="ownership/nll/title.html"><strong aria-hidden="true">3.25.</strong> Briefly: Non-Lexical Lifetimes</a></li><li><ol class="section"><li><a href="ownership/nll/the_borrow_checker_in_rust_2015.html"><strong aria-hidden="true">3.25.1.</strong> The Borrow Checker in Rust 2015</a></li><li><a href="ownership/nll/the_borrow_checker_in_rust_2018.html"><strong aria-hidden="true">3.25.2.</strong> The Borrow Checker in Rust 2018</a></li></ol></li><li><a href="ownership/mixed_mutable_references.html"><strong aria-hidden="true">3.26.</strong> Mixed Mutable References</a></li><li><a href="ownership/dangling_pointers.html"><strong aria-hidden="true">3.27.</strong> Dangling Pointers</a></li><li><a href="ownership/dangling_references.html"><strong aria-hidden="true">3.28.</strong> Dangling References</a></li><li><a href="ownership/rules_of_references.html"><strong aria-hidden="true">3.29.</strong> Rules of References</a></li><li><a href="ownership/slices/title.html"><strong aria-hidden="true">3.30.</strong> Slices</a></li><li><ol class="section"><li><a href="ownership/slices/string_slices_1.html"><strong aria-hidden="true">3.30.1.</strong> String Slices 1</a></li><li><a href="ownership/slices/string_slices_2.html"><strong aria-hidden="true">3.30.2.</strong> String Slices 2</a></li><li><a href="ownership/slices/string_literal_slices.html"><strong aria-hidden="true">3.30.3.</strong> String Literal Slices</a></li><li><a href="ownership/slices/other_slices.html"><strong aria-hidden="true">3.30.4.</strong> Other Slices</a></li></ol></li><li><a href="ownership/recap.html"><strong aria-hidden="true">3.31.</strong> Recap</a></li></ol></li><li><a href="structs_enums_crates/title.html"><strong aria-hidden="true">4.</strong> Structs, Enums and Crates</a></li><li><ol class="section"><li><a href="structs_enums_crates/last_time.html"><strong aria-hidden="true">4.1.</strong> Last Time</a></li><li><a href="structs_enums_crates/quote.html"><strong aria-hidden="true">4.2.</strong> Quote</a></li><li><a href="structs_enums_crates/structs/title.html"><strong aria-hidden="true">4.3.</strong> Structs</a></li><li><ol class="section"><li><a href="structs_enums_crates/structs/declaration.html"><strong aria-hidden="true">4.3.1.</strong> Declaration</a></li><li><a href="structs_enums_crates/structs/instantiation.html"><strong aria-hidden="true">4.3.2.</strong> Instantiation</a></li><li><a href="structs_enums_crates/structs/modification.html"><strong aria-hidden="true">4.3.3.</strong> Modification</a></li><li><a href="structs_enums_crates/structs/constructor_short_hand.html"><strong aria-hidden="true">4.3.4.</strong> Constructor Short Hand</a></li><li><a href="structs_enums_crates/structs/update_syntax.html"><strong aria-hidden="true">4.3.5.</strong> Update Syntax</a></li><li><a href="structs_enums_crates/structs/tuple_structs.html"><strong aria-hidden="true">4.3.6.</strong> Tuple Structs</a></li><li><a href="structs_enums_crates/structs/unit_structs.html"><strong aria-hidden="true">4.3.7.</strong> Unit Structs</a></li><li><a href="structs_enums_crates/structs/ownership_1.html"><strong aria-hidden="true">4.3.8.</strong> Ownership 1</a></li><li><a href="structs_enums_crates/structs/ownership_2.html"><strong aria-hidden="true">4.3.9.</strong> Ownership 2</a></li><li><a href="structs_enums_crates/structs/adding_meaning.html"><strong aria-hidden="true">4.3.10.</strong> Adding Meaning</a></li><li><a href="structs_enums_crates/structs/adding_functionality_with_derived_traits_1.html"><strong aria-hidden="true">4.3.11.</strong> Adding Functionality with Derived Traits 1</a></li><li><a href="structs_enums_crates/structs/adding_functionality_with_derived_traits_2.html"><strong aria-hidden="true">4.3.12.</strong> Adding Functionality with Derived Traits 2</a></li><li><a href="structs_enums_crates/structs/adding_functionality_with_derived_traits_3.html"><strong aria-hidden="true">4.3.13.</strong> Adding Functionality with Derived Traits 3</a></li><li><a href="structs_enums_crates/structs/defining_methods.html"><strong aria-hidden="true">4.3.14.</strong> Defining Methods</a></li><li><a href="structs_enums_crates/structs/where_did_the_arrow_operator_go_1.html"><strong aria-hidden="true">4.3.15.</strong> Where did -&gt; go? 1</a></li><li><a href="structs_enums_crates/structs/where_did_the_arrow_operator_go_2.html"><strong aria-hidden="true">4.3.16.</strong> Where did -&gt; go? 2</a></li><li><a href="structs_enums_crates/structs/methods_with_more_parameters.html"><strong aria-hidden="true">4.3.17.</strong> Methods With More Parameters</a></li><li><a href="structs_enums_crates/structs/assocated_functions.html"><strong aria-hidden="true">4.3.18.</strong> Associated Functions</a></li><li><a href="structs_enums_crates/structs/multiple_impl_blocks.html"><strong aria-hidden="true">4.3.19.</strong> Multiple impl Blocks</a></li><li><a href="structs_enums_crates/structs/recap.html"><strong aria-hidden="true">4.3.20.</strong> Recap</a></li></ol></li></ol></li><li><a href="collections/title.html"><strong aria-hidden="true">5.</strong> Common Collections</a></li><li><ol class="section"><li><a href="collections/last_time.html"><strong aria-hidden="true">5.1.</strong> Last Time</a></li><li><a href="collections/quote.html"><strong aria-hidden="true">5.2.</strong> Quote</a></li><li><a href="collections/the_std_library.html"><strong aria-hidden="true">5.3.</strong> The Standard Library</a></li><li><a href="collections/stdlib_tour.html"><strong aria-hidden="true">5.4.</strong> A Quick Tour</a></li><li><a href="collections/collection_types.html"><strong aria-hidden="true">5.5.</strong> Collection Types</a></li><li><a href="collections/vector/title.html"><strong aria-hidden="true">5.6.</strong> Vectors</a></li><li><ol class="section"><li><a href="collections/vector/basics.html"><strong aria-hidden="true">5.6.1.</strong> Basics</a></li><li><a href="collections/vector/reading_elements_1.html"><strong aria-hidden="true">5.6.2.</strong> Reading Elements 1</a></li><li><a href="collections/vector/reading_elements_2.html"><strong aria-hidden="true">5.6.3.</strong> Reading Elements 2</a></li><li><a href="collections/vector/reading_elements_3.html"><strong aria-hidden="true">5.6.4.</strong> Reading Elements 3</a></li><li><a href="collections/vector/iterating_over_values.html"><strong aria-hidden="true">5.6.5.</strong> Iterating over Values</a></li><li><a href="collections/vector/storing_multiple_types.html"><strong aria-hidden="true">5.6.6.</strong> Storing Multiple Types</a></li></ol></li><li><a href="collections/hash_map/title.html"><strong aria-hidden="true">5.7.</strong> Hash Maps</a></li><li><ol class="section"><li><a href="collections/hash_map/basics_1.html"><strong aria-hidden="true">5.7.1.</strong> Basics 1</a></li><li><a href="collections/hash_map/basics_2.html"><strong aria-hidden="true">5.7.2.</strong> Basics 2</a></li><li><a href="collections/hash_map/ownership.html"><strong aria-hidden="true">5.7.3.</strong> Ownership</a></li><li><a href="collections/hash_map/accessing_values_1.html"><strong aria-hidden="true">5.7.4.</strong> Accessing Values</a></li><li><a href="collections/hash_map/accessing_values_2.html"><strong aria-hidden="true">5.7.5.</strong> Accessing Values</a></li><li><a href="collections/hash_map/updating_values_1.html"><strong aria-hidden="true">5.7.6.</strong> Updating Values</a></li><li><a href="collections/hash_map/updating_values_2.html"><strong aria-hidden="true">5.7.7.</strong> Updating Values</a></li><li><a href="collections/hash_map/updating_values_3.html"><strong aria-hidden="true">5.7.8.</strong> Updating Values</a></li><li><a href="collections/hash_map/hashing_functions.html"><strong aria-hidden="true">5.7.9.</strong> Hashing Functions</a></li></ol></li><li><a href="collections/emoji_fzf_part_4/title.html"><strong aria-hidden="true">5.8.</strong> Emoji-fzf: Part 4</a></li><li><ol class="section"><li><a href="collections/emoji_fzf_part_4/last_time.html"><strong aria-hidden="true">5.8.1.</strong> Last Time</a></li><li><a href="collections/emoji_fzf_part_4/assignment_1.html"><strong aria-hidden="true">5.8.2.</strong> Assignment 1</a></li><li><a href="collections/emoji_fzf_part_4/answer_1.html"><strong aria-hidden="true">5.8.3.</strong> Answer 1</a></li><li><a href="collections/emoji_fzf_part_4/assignment_2.html"><strong aria-hidden="true">5.8.4.</strong> Assignment 2</a></li><li><a href="collections/emoji_fzf_part_4/answer_2.html"><strong aria-hidden="true">5.8.5.</strong> Answer 2</a></li><li><a href="collections/emoji_fzf_part_4/today.html"><strong aria-hidden="true">5.8.6.</strong> Today</a></li><li><a href="collections/emoji_fzf_part_4/preview_subcommand.html"><strong aria-hidden="true">5.8.7.</strong> The Preview Subcommand</a></li><li><a href="collections/emoji_fzf_part_4/serde_intro.html"><strong aria-hidden="true">5.8.8.</strong> Introducing Serde</a></li><li><a href="collections/emoji_fzf_part_4/serde_example.html"><strong aria-hidden="true">5.8.9.</strong> A Serde Example</a></li><li><a href="collections/emoji_fzf_part_4/mapping_emojis_1.html"><strong aria-hidden="true">5.8.10.</strong> Mapping Emojis.json 1</a></li><li><a href="collections/emoji_fzf_part_4/mapping_emojis_2.html"><strong aria-hidden="true">5.8.11.</strong> Mapping Emojis.json 2</a></li><li><a href="collections/emoji_fzf_part_4/new_assignments.html"><strong aria-hidden="true">5.8.12.</strong> Assignments</a></li></ol></li></ol></li><li><a href="errors/title.html"><strong aria-hidden="true">6.</strong> Error Handling</a></li><li><ol class="section"><li><a href="errors/last_time.html"><strong aria-hidden="true">6.1.</strong> Last Time</a></li><li><a href="errors/quote.html"><strong aria-hidden="true">6.2.</strong> Quote</a></li><li><a href="errors/intro.html"><strong aria-hidden="true">6.3.</strong> Introduction</a></li><li><a href="errors/panic.html"><strong aria-hidden="true">6.4.</strong> Panic!</a></li><li><a href="errors/panic_backtrace_1.html"><strong aria-hidden="true">6.5.</strong> Panic Backtrace 1</a></li><li><a href="errors/panic_backtrace_2.html"><strong aria-hidden="true">6.6.</strong> Panic Backtrace 2</a></li><li><a href="errors/result.html"><strong aria-hidden="true">6.7.</strong> Result</a></li><li><a href="errors/using_result.html"><strong aria-hidden="true">6.8.</strong> Using Result</a></li><li><a href="errors/matching_result.html"><strong aria-hidden="true">6.9.</strong> Matching Result</a></li><li><a href="errors/matching_result_errors_1.html"><strong aria-hidden="true">6.10.</strong> Matching Result Errors 1</a></li><li><a href="errors/matching_result_errors_2.html"><strong aria-hidden="true">6.11.</strong> Matching Result Errors 2</a></li><li><a href="errors/unwrap.html"><strong aria-hidden="true">6.12.</strong> Shortcuts for Panic: Unwrap</a></li><li><a href="errors/expect.html"><strong aria-hidden="true">6.13.</strong> Shortcuts for Panic: Expect</a></li><li><a href="errors/propagating_errors_1.html"><strong aria-hidden="true">6.14.</strong> Propagating Errors 1</a></li><li><a href="errors/propagating_errors_2.html"><strong aria-hidden="true">6.15.</strong> Propagating Errors 2</a></li><li><a href="errors/propagating_errors_3.html"><strong aria-hidden="true">6.16.</strong> Propagating Errors 3</a></li><li><a href="errors/question_mark_operator_1.html"><strong aria-hidden="true">6.17.</strong> The ? Operator 1</a></li><li><a href="errors/question_mark_operator_2.html"><strong aria-hidden="true">6.18.</strong> The ? Operator 2</a></li><li><a href="errors/when_to_panic.html"><strong aria-hidden="true">6.19.</strong> To panic! or Not to panic!</a></li><li><a href="errors/emoji_fzf_part_5/title.html"><strong aria-hidden="true">6.20.</strong> Emoji-fzf: Part 5</a></li><li><ol class="section"><li><a href="errors/emoji_fzf_part_5/last_time.html"><strong aria-hidden="true">6.20.1.</strong> Last Time</a></li><li><a href="errors/emoji_fzf_part_5/assignment_1.html"><strong aria-hidden="true">6.20.2.</strong> Assignment 1</a></li><li><a href="errors/emoji_fzf_part_5/answer_1.html"><strong aria-hidden="true">6.20.3.</strong> Answer 1</a></li><li><a href="errors/emoji_fzf_part_5/assignment_2.html"><strong aria-hidden="true">6.20.4.</strong> Assignment 2</a></li><li><a href="errors/emoji_fzf_part_5/answer_2.html"><strong aria-hidden="true">6.20.5.</strong> Answer 2</a></li><li><a href="errors/emoji_fzf_part_5/assignment_3.html"><strong aria-hidden="true">6.20.6.</strong> Assignment 3</a></li><li><a href="errors/emoji_fzf_part_5/answer_3.html"><strong aria-hidden="true">6.20.7.</strong> Answer 3</a></li><li><a href="errors/emoji_fzf_part_5/assignment_4.html"><strong aria-hidden="true">6.20.8.</strong> Assignment 4</a></li><li><a href="errors/emoji_fzf_part_5/answer_4.html"><strong aria-hidden="true">6.20.9.</strong> Answer 4</a></li><li><a href="errors/emoji_fzf_part_5/new_assignments.html"><strong aria-hidden="true">6.20.10.</strong> Assignments</a></li></ol></li></ol></li><li><a href="generics/title.html"><strong aria-hidden="true">7.</strong> Generics</a></li><li><ol class="section"><li><a href="generics/last_time.html"><strong aria-hidden="true">7.1.</strong> Last Time</a></li><li><a href="generics/quote.html"><strong aria-hidden="true">7.2.</strong> Quote</a></li><li><a href="generics/intro.html"><strong aria-hidden="true">7.3.</strong> Introduction</a></li><li><a href="generics/removing_duplication_1.html"><strong aria-hidden="true">7.4.</strong> Removing Duplication 1</a></li><li><a href="generics/removing_duplication_2.html"><strong aria-hidden="true">7.5.</strong> Removing Duplication 2</a></li><li><a href="generics/removing_duplication_3.html"><strong aria-hidden="true">7.6.</strong> Removing Duplication 3</a></li><li><a href="generics/removing_duplication_4.html"><strong aria-hidden="true">7.7.</strong> Removing Duplication 4</a></li><li><a href="generics/structs_1.html"><strong aria-hidden="true">7.8.</strong> Generic Structs 1</a></li><li><a href="generics/structs_2.html"><strong aria-hidden="true">7.9.</strong> Generic Structs 2</a></li><li><a href="generics/structs_3.html"><strong aria-hidden="true">7.10.</strong> Generic Structs 3</a></li><li><a href="generics/enums.html"><strong aria-hidden="true">7.11.</strong> Generic Enums</a></li><li><a href="generics/methods_1.html"><strong aria-hidden="true">7.12.</strong> Generic Methods 1</a></li><li><a href="generics/methods_2.html"><strong aria-hidden="true">7.13.</strong> Generic Methods 2</a></li><li><a href="generics/methods_3.html"><strong aria-hidden="true">7.14.</strong> Generic Methods 3</a></li><li><a href="generics/performance_1.html"><strong aria-hidden="true">7.15.</strong> Performance 1</a></li><li><a href="generics/performance_2.html"><strong aria-hidden="true">7.16.</strong> Performance 2</a></li><li><a href="generics/workshop/title.html"><strong aria-hidden="true">7.17.</strong> Workshop</a></li><li><ol class="section"><li><a href="generics/workshop/question_1.html"><strong aria-hidden="true">7.17.1.</strong> Question 1</a></li><li><a href="generics/workshop/answer_1.html"><strong aria-hidden="true">7.17.2.</strong> Answer 1</a></li><li><a href="generics/workshop/question_2.html"><strong aria-hidden="true">7.17.3.</strong> Question 2</a></li><li><a href="generics/workshop/answer_2.html"><strong aria-hidden="true">7.17.4.</strong> Answer 2</a></li><li><a href="generics/workshop/question_3.html"><strong aria-hidden="true">7.17.5.</strong> Question 3</a></li><li><a href="generics/workshop/answer_3.html"><strong aria-hidden="true">7.17.6.</strong> Answer 3</a></li><li><a href="generics/workshop/question_4.html"><strong aria-hidden="true">7.17.7.</strong> Question 4</a></li><li><a href="generics/workshop/answer_4.html"><strong aria-hidden="true">7.17.8.</strong> Answer 4</a></li></ol></li></ol></li><li><a href="traits/title.html"><strong aria-hidden="true">8.</strong> Traits</a></li><li><ol class="section"><li><a href="traits/last_time.html"><strong aria-hidden="true">8.1.</strong> Last Time</a></li><li><a href="traits/quote.html"><strong aria-hidden="true">8.2.</strong> Quote</a></li><li><a href="traits/intro.html"><strong aria-hidden="true">8.3.</strong> Introduction</a></li><li><a href="traits/defining_traits.html"><strong aria-hidden="true">8.4.</strong> Defining a Trait</a></li><li><a href="traits/implementing_traits_1.html"><strong aria-hidden="true">8.5.</strong> Implementing Traits 1</a></li><li><a href="traits/implementing_traits_2.html"><strong aria-hidden="true">8.6.</strong> Implementing Traits 2</a></li><li><a href="traits/implementing_traits_3.html"><strong aria-hidden="true">8.7.</strong> Implementing Traits 3</a></li><li><a href="traits/default_implementations_1.html"><strong aria-hidden="true">8.8.</strong> Default Implementations 1</a></li><li><a href="traits/default_implementations_2.html"><strong aria-hidden="true">8.9.</strong> Default Implementations 2</a></li><li><a href="traits/parameters/title.html"><strong aria-hidden="true">8.10.</strong> Traits as Parameters</a></li><li><ol class="section"><li><a href="traits/parameters/trait_bound.html"><strong aria-hidden="true">8.10.1.</strong> Trait Bound Syntax</a></li><li><a href="traits/parameters/trait_bounds.html"><strong aria-hidden="true">8.10.2.</strong> Trait Bounds Syntax</a></li><li><a href="traits/parameters/where_clauses.html"><strong aria-hidden="true">8.10.3.</strong> Where Clauses</a></li></ol></li><li><a href="traits/returning_types_that_implement_traits_1.html"><strong aria-hidden="true">8.11.</strong> Returning Types that Implement Traits 1</a></li><li><a href="traits/returning_types_that_implement_traits_2.html"><strong aria-hidden="true">8.12.</strong> Returning Types that Implement Traits 2</a></li><li><a href="traits/fixing_the_largest_function_1.html"><strong aria-hidden="true">8.13.</strong> Fixing the Largest Function 1</a></li><li><a href="traits/fixing_the_largest_function_2.html"><strong aria-hidden="true">8.14.</strong> Fixing the Largest Function 2</a></li><li><a href="traits/fixing_the_largest_function_3.html"><strong aria-hidden="true">8.15.</strong> Fixing the Largest Function 3</a></li><li><a href="traits/trait_bounds_conditional_methods_1.html"><strong aria-hidden="true">8.16.</strong> Using Trait Bounds to Conditionally Implement Methods 1</a></li><li><a href="traits/trait_bounds_conditional_methods_2.html"><strong aria-hidden="true">8.17.</strong> Using Trait Bounds to Conditionally Implement Methods 2</a></li><li><a href="traits/recap.html"><strong aria-hidden="true">8.18.</strong> Recap</a></li><li><a href="traits/workshop/title.html"><strong aria-hidden="true">8.19.</strong> Workshop</a></li><li><ol class="section"><li><a href="traits/workshop/question_1.html"><strong aria-hidden="true">8.19.1.</strong> Question 1</a></li><li><a href="traits/workshop/answer_1.html"><strong aria-hidden="true">8.19.2.</strong> Answer 1</a></li><li><a href="traits/workshop/question_2.html"><strong aria-hidden="true">8.19.3.</strong> Question 2</a></li><li><a href="traits/workshop/answer_2.html"><strong aria-hidden="true">8.19.4.</strong> Answer 2</a></li><li><a href="traits/workshop/question_3.html"><strong aria-hidden="true">8.19.5.</strong> Question 3</a></li><li><a href="traits/workshop/answer_3.html"><strong aria-hidden="true">8.19.6.</strong> Answer 3</a></li></ol></li></ol></li><li><a href="lifetimes/title.html"><strong aria-hidden="true">9.</strong> Lifetimes</a></li><li><ol class="section"><li><a href="lifetimes/last_time.html"><strong aria-hidden="true">9.1.</strong> Last Time</a></li><li><a href="lifetimes/quote.html"><strong aria-hidden="true">9.2.</strong> Quote</a></li><li><a href="lifetimes/intro.html"><strong aria-hidden="true">9.3.</strong> Introduction</a></li><li><a href="lifetimes/dangling_references.html"><strong aria-hidden="true">9.4.</strong> Preventing Dangling References</a></li><li><a href="lifetimes/borrow_checker.html"><strong aria-hidden="true">9.5.</strong> The Borrow Checker</a></li><li><a href="lifetimes/generic_lifetimes_in_functions_1.html"><strong aria-hidden="true">9.6.</strong> Generic Lifetimes in Functions 1</a></li><li><a href="lifetimes/generic_lifetimes_in_functions_2.html"><strong aria-hidden="true">9.7.</strong> Generic Lifetimes in Functions 2</a></li><li><a href="lifetimes/lifetime_annotation_syntax.html"><strong aria-hidden="true">9.8.</strong> Lifetime Annotation Syntax</a></li><li><a href="lifetimes/lifetime_annotations_in_function_signatures_1.html"><strong aria-hidden="true">9.9.</strong> Lifetime Annotations in Function Signatures 1</a></li><li><a href="lifetimes/lifetime_annotations_in_function_signatures_2.html"><strong aria-hidden="true">9.10.</strong> Lifetime Annotations in Function Signatures 2</a></li><li><a href="lifetimes/lifetime_annotations_in_function_signatures_3.html"><strong aria-hidden="true">9.11.</strong> Lifetime Annotations in Function Signatures 3</a></li><li><a href="lifetimes/thinking_in_terms_of_lifetimes_1.html"><strong aria-hidden="true">9.12.</strong> Thinking in Terms of Lifetimes 1</a></li><li><a href="lifetimes/thinking_in_terms_of_lifetimes_2.html"><strong aria-hidden="true">9.13.</strong> Thinking in Terms of Lifetimes 2</a></li><li><a href="lifetimes/struct_definition_lifetimes.html"><strong aria-hidden="true">9.14.</strong> Lifetime Annotations in Struct Definitions</a></li><li><a href="lifetimes/elision_1.html"><strong aria-hidden="true">9.15.</strong> Lifetime Elision 1</a></li><li><a href="lifetimes/elision_2.html"><strong aria-hidden="true">9.16.</strong> Lifetime Elision 2</a></li><li><a href="lifetimes/method_definition_lifetimes.html"><strong aria-hidden="true">9.17.</strong> Lifetime Annotations in Method Definitions</a></li><li><a href="lifetimes/static_lifetime.html"><strong aria-hidden="true">9.18.</strong> The Static Lifetime</a></li><li><a href="lifetimes/all_together.html"><strong aria-hidden="true">9.19.</strong> Generics, Trait Bounds, and Lifetimes Together</a></li><li><a href="lifetimes/recap.html"><strong aria-hidden="true">9.20.</strong> Recap</a></li><li><a href="lifetimes/workshop/title.html"><strong aria-hidden="true">9.21.</strong> Workshop</a></li><li><ol class="section"><li><a href="lifetimes/workshop/question_1.html"><strong aria-hidden="true">9.21.1.</strong> Question 1</a></li><li><a href="lifetimes/workshop/answer_1.html"><strong aria-hidden="true">9.21.2.</strong> Answer 1</a></li><li><a href="lifetimes/workshop/question_2.html"><strong aria-hidden="true">9.21.3.</strong> Question 2</a></li><li><a href="lifetimes/workshop/answer_2.html"><strong aria-hidden="true">9.21.4.</strong> Answer 2</a></li><li><a href="lifetimes/workshop/question_3.html"><strong aria-hidden="true">9.21.5.</strong> Question 3</a></li><li><a href="lifetimes/workshop/answer_3.html"><strong aria-hidden="true">9.21.6.</strong> Answer 3</a></li></ol></li></ol></li><li><a href="testing/title.html"><strong aria-hidden="true">10.</strong> Automated Testing</a></li><li><ol class="section"><li><a href="testing/last_time.html"><strong aria-hidden="true">10.1.</strong> Last Time</a></li><li><a href="testing/quote.html"><strong aria-hidden="true">10.2.</strong> Quote</a></li><li><a href="testing/intro.html"><strong aria-hidden="true">10.3.</strong> Introduction</a></li><li><a href="testing/anatomy_of_a_test_function.html"><strong aria-hidden="true">10.4.</strong> Anatomy of a Test Function</a></li><li><a href="testing/asserting_results.html"><strong aria-hidden="true">10.5.</strong> Asserting Results</a></li><li><a href="testing/testing_equality.html"><strong aria-hidden="true">10.6.</strong> Testing Equality</a></li><li><a href="testing/custom_failure_messages.html"><strong aria-hidden="true">10.7.</strong> Custom Failure Messages</a></li><li><a href="testing/checking_for_panics.html"><strong aria-hidden="true">10.8.</strong> Checking for Panics</a></li><li><a href="testing/using_result_in_tests.html"><strong aria-hidden="true">10.9.</strong> Using Result in Tests</a></li><li><a href="testing/running_tests.html"><strong aria-hidden="true">10.10.</strong> Running Tests</a></li><li><a href="testing/showing_function_output.html"><strong aria-hidden="true">10.11.</strong> Showing Function Output</a></li><li><a href="testing/ignoring_tests.html"><strong aria-hidden="true">10.12.</strong> Ignoring Tests</a></li><li><a href="testing/unit_tests.html"><strong aria-hidden="true">10.13.</strong> Unit Tests</a></li><li><a href="testing/integration_tests.html"><strong aria-hidden="true">10.14.</strong> Integration Tests</a></li><li><a href="testing/mocking.html"><strong aria-hidden="true">10.15.</strong> Mocking</a></li><li><a href="testing/workshop/title.html"><strong aria-hidden="true">10.16.</strong> Workshop</a></li><li><ol class="section"><li><a href="testing/workshop/creating_a_library_crate.html"><strong aria-hidden="true">10.16.1.</strong> Creating a Library Crate</a></li><li><a href="testing/workshop/adding_functionality.html"><strong aria-hidden="true">10.16.2.</strong> Adding Functionality</a></li><li><a href="testing/workshop/unit_testing.html"><strong aria-hidden="true">10.16.3.</strong> Unit Testing</a></li><li><a href="testing/workshop/integration_testing.html"><strong aria-hidden="true">10.16.4.</strong> Integration Testing</a></li><li><a href="testing/workshop/benchmark_testing.html"><strong aria-hidden="true">10.16.5.</strong> Benchmark Testing</a></li><li><a href="testing/workshop/introducing_criterion.html"><strong aria-hidden="true">10.16.6.</strong> Introducing Criterion.rs</a></li><li><a href="testing/workshop/setting_up_criterion_1.html"><strong aria-hidden="true">10.16.7.</strong> Setting up Criterion.rs</a></li><li><a href="testing/workshop/setting_up_criterion_2.html"><strong aria-hidden="true">10.16.8.</strong> Setting up Criterion.rs</a></li><li><a href="testing/workshop/comparing_benchmarks.html"><strong aria-hidden="true">10.16.9.</strong> Comparing Benchmarks</a></li></ol></li></ol></li><li><a href="closures/title.html"><strong aria-hidden="true">11.</strong> Closures</a></li><li><ol class="section"><li><a href="closures/last_time.html"><strong aria-hidden="true">11.1.</strong> Last Time</a></li><li><a href="closures/quote.html"><strong aria-hidden="true">11.2.</strong> Quote</a></li><li><a href="closures/intro.html"><strong aria-hidden="true">11.3.</strong> Introduction</a></li><li><a href="closures/what_are_closures.html"><strong aria-hidden="true">11.4.</strong> What Are Closures</a></li><li><a href="closures/c_function_pointers.html"><strong aria-hidden="true">11.5.</strong> C Function Pointers</a></li><li><a href="closures/abstracting_behavior_1.html"><strong aria-hidden="true">11.6.</strong> Abstracting Behavior 1</a></li><li><a href="closures/abstracting_behavior_2.html"><strong aria-hidden="true">11.7.</strong> Abstracting Behavior 2</a></li><li><a href="closures/abstracting_behavior_3.html"><strong aria-hidden="true">11.8.</strong> Abstracting Behavior 3</a></li><li><a href="closures/inference_and_annotation.html"><strong aria-hidden="true">11.9.</strong> Type Inference and Annotation</a></li><li><a href="closures/storing_closures_using_generic_parameters_1.html"><strong aria-hidden="true">11.10.</strong> Storing Closures using Generic Parameters 1</a></li><li><a href="closures/storing_closures_using_generic_parameters_2.html"><strong aria-hidden="true">11.11.</strong> Storing Closures using Generic Parameters 2</a></li><li><a href="closures/storing_closures_using_generic_parameters_3.html"><strong aria-hidden="true">11.12.</strong> Storing Closures using Generic Parameters 3</a></li><li><a href="closures/capturing_the_environment_1.html"><strong aria-hidden="true">11.13.</strong> Capturing the Environment 1</a></li><li><a href="closures/capturing_the_environment_2.html"><strong aria-hidden="true">11.14.</strong> Capturing the Environment 2</a></li><li><a href="closures/the_fn_traits_1.html"><strong aria-hidden="true">11.15.</strong> The Fn Traits 1</a></li><li><a href="closures/the_fn_traits_2.html"><strong aria-hidden="true">11.16.</strong> The Fn Traits 2</a></li><li><a href="closures/move_closures.html"><strong aria-hidden="true">11.17.</strong> Move Closures</a></li><li><a href="closures/recap.html"><strong aria-hidden="true">11.18.</strong> Recap</a></li><li><a href="closures/workshop/title.html"><strong aria-hidden="true">11.19.</strong> Workshop</a></li><li><ol class="section"><li><a href="closures/workshop/question_1.html"><strong aria-hidden="true">11.19.1.</strong> Question 1</a></li><li><a href="closures/workshop/answer_1.html"><strong aria-hidden="true">11.19.2.</strong> Answer 1</a></li><li><a href="closures/workshop/question_2.html"><strong aria-hidden="true">11.19.3.</strong> Question 2</a></li><li><a href="closures/workshop/answer_2.html"><strong aria-hidden="true">11.19.4.</strong> Answer 2</a></li></ol></li></ol></li><li><a href="iterators/title.html"><strong aria-hidden="true">12.</strong> Iterators</a></li><li><ol class="section"><li><a href="iterators/last_time.html"><strong aria-hidden="true">12.1.</strong> Last Time</a></li><li><a href="iterators/quote.html"><strong aria-hidden="true">12.2.</strong> Quote</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust Workshop</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rust-workshop-series" id="rust-workshop-series">Rust Workshop Series</a></h1>
<blockquote>
<p>Note: This book is currently a WIP. Some sections may be missing or
incomplete.</p>
</blockquote>
<p>The following book contains a series chapters designed to be presented to
newcomers to the Rust programming language. Each chapter, otherwise know as
talk, is designed to be approximately an hour long and feature both a speaking
portion as well as a more interactive 'build something' workshop portion. The
ideal time split between the lecture and workshop sections is 50/50.</p>
<h2><a class="header" href="#content" id="content">Content</a></h2>
<p>The content of the workshop is largely inspired by the official
<a href="https://doc.rust-lang.org/book/">book</a> with some modifications. Since the Rust
community moves quickly, some content can become stale and could potentially be
older or newer than the book. Best efforts will be made to keep the workshop
content up to date. Furthermore, the workshop is largely geared toward C or
embedded C programmers currently. Since it is based on the book, the content
is general enough for people of various programming backgrounds to understand.
It is important to note, however, most low level or C-like concepts will get
less focus than some of the other elements of the language like ownership,
generics, lifetimes, traits and functional features.</p>
<h2><a class="header" href="#source-code" id="source-code">Source Code</a></h2>
<p>The source file from which the workshop is generated can be found on
<a href="https://github.com/mvertescher/workshop-rs">GitHub</a>.</p>
<h1><a class="header" href="#rust-workshop-part-i" id="rust-workshop-part-i">Rust Workshop: Part I</a></h1>
<h2><a class="header" href="#introduction-and-cargo" id="introduction-and-cargo">Introduction and Cargo</a></h2>
<h1><a class="header" href="#what-is-rust-exactly" id="what-is-rust-exactly">What <em>is</em> Rust Exactly?</a></h1>
<h3><a class="header" href="#rust-is-a-systems-language-pursuing-the-trifectabr-safety-concurrency-and-speed" id="rust-is-a-systems-language-pursuing-the-trifectabr-safety-concurrency-and-speed">Rust is a <em>Systems language</em> pursuing the trifecta:<br> safety, concurrency, and speed</a></h3>
<h3><a class="header" href="#the-community-provides-an-ecosystem-of-tools-and-packages-br-to-be-productive-in-rust" id="the-community-provides-an-ecosystem-of-tools-and-packages-br-to-be-productive-in-rust">The community provides an ecosystem of tools and packages <br> to be <em>productive</em> in Rust</a></h3>
<h1><a class="header" href="#the-type-system" id="the-type-system">The Type System</a></h1>
<h3><a class="header" href="#statically-typed-type-errors-are-detected-at-compile-time" id="statically-typed-type-errors-are-detected-at-compile-time"><strong>Statically Typed</strong>: Type errors are detected at compile time</a></h3>
<h3><a class="header" href="#type-safe-the-language-limits-what-operation-can-be-performed-on-which-types-of-data" id="type-safe-the-language-limits-what-operation-can-be-performed-on-which-types-of-data"><strong>Type Safe</strong>: The language limits what operation can be performed on which types of data</a></h3>
<p>i.e. No C-like type casting. Strong type enforcement.</p>
<h1><a class="header" href="#pillars-of-rust" id="pillars-of-rust">Pillars of Rust</a></h1>
<h3><a class="header" href="#memory-safety-without-garbage-collection-rust-uses-ownership-to-enforce-access-control-of-data-at-compile-time" id="memory-safety-without-garbage-collection-rust-uses-ownership-to-enforce-access-control-of-data-at-compile-time"><strong>Memory safety without garbage collection</strong>: Rust uses <em>ownership</em> to enforce access control of data at compile time</a></h3>
<h3><a class="header" href="#concurrency-without-data-races-also-a-product-of-the-ownership-system" id="concurrency-without-data-races-also-a-product-of-the-ownership-system"><strong>Concurrency without data races</strong>: Also a product of the <em>ownership</em> system</a></h3>
<h3><a class="header" href="#zero-cost-abstractions-traits-rust-is-similar-to-c" id="zero-cost-abstractions-traits-rust-is-similar-to-c"><strong>Zero cost abstractions</strong>: <em>Traits</em>. Rust is similar to C++:</a></h3>
<blockquote>
<p>C++ implementations obey the zero-overhead principle: What you don't use,
you don't pay for [Stroustrup, 1994]. And further: What you do use, you
couldn't hand code any better.</p>
<p>-- Stroustrup</p>
</blockquote>
<h1><a class="header" href="#a-short-timeline" id="a-short-timeline">A Short Timeline</a></h1>
<ul>
<li><strong>2006</strong>: Frustrated with C++, Graydon Hoare starts a pet project...</li>
<li><strong>2009</strong>: An early version of Rust is introduced internally at Mozilla for development</li>
<li><strong>2010</strong>: Rust officially announced by Mozilla</li>
<li><strong>2013</strong>: Graydon leaves the Rust project; Federated governance for Rust</li>
<li><strong>2015</strong>: Rust 1.0.0 (stable) is released</li>
<li><strong>2017</strong>: Firefox Quantum (including Servo) released</li>
<li><strong>2018</strong>: Rust 2018 is released</li>
</ul>
<h1><a class="header" href="#tools" id="tools">Tools</a></h1>
<ul>
<li>Toolchain management: <strong>rustup</strong></li>
<li>Build/Testing/Publishing: <strong>cargo</strong></li>
<li>Documentation: <strong>rustdoc</strong></li>
<li>Formatting: <strong>rustfmt</strong></li>
<li>Static Analysis: <strong>clippy</strong></li>
<li>Editor autocomplete: <strong>racer</strong></li>
<li>C/C++ bindings generator: <strong>bindgen</strong></li>
<li>Code size profiling: <strong>twiggy</strong></li>
<li>IDE support: <strong>Rust Language Server (RLS)</strong></li>
</ul>
<h1><a class="header" href="#community" id="community">Community</a></h1>
<ul>
<li>There is one package registry called <a href="https://crates.io"><strong>crates.io</strong></a>.</li>
<li>A software package in Rust is called a <strong>crate</strong>.</li>
<li>There are ~24000 crates on <a href="https://crates.io"><strong>crates.io</strong></a> today.</li>
<li>Anyone can upload a new crate using <strong>cargo</strong>.</li>
</ul>
<h1><a class="header" href="#domains" id="domains">Domains</a></h1>
<h3><a class="header" href="#where-is-rust-used-today" id="where-is-rust-used-today">Where is Rust used today?</a></h3>
<ul>
<li>CLI Tools</li>
<li>Networking</li>
<li>WebAssembly</li>
<li>Graphics/Game Engines</li>
<li>Operating Systems</li>
<li>Embedded</li>
</ul>
<h1><a class="header" href="#some-wisdom" id="some-wisdom">Some Wisdom</a></h1>
<blockquote>
<p>It wasnt always so clear, but the Rust programming language is fundamentally
about empowerment: no matter what kind of code you are writing now, Rust
empowers you to reach farther, to program with confidence in a wider variety
of domains than you did before.</p>
<p> Nicholas Matsakis and Aaron Turon</p>
</blockquote>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started!</a></h1>
<h3><a class="header" href="#lets-build-hello-world" id="lets-build-hello-world">Let's build hello world!</a></h3>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#installing-rust" id="installing-rust">Installing Rust</a></h1>
<p>Fetch <strong>rustup</strong> using curl:</p>
<pre><code class="language-sh">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>Be sure to add the tools to your path (if necessary):</p>
<pre><code class="language-sh">$ export PATH=&quot;$PATH:~/.cargo/bin&quot;
</code></pre>
<p>Optionally, restart your console!</p>
<h1><a class="header" href="#rustup" id="rustup">Rustup</a></h1>
<p><code>rustup</code> manages versions of the complier and standard library.</p>
<pre><code class="language-sh">$ rustup -h
</code></pre>
<pre><code class="language-plaintext">SUBCOMMANDS:
    show           Show the active and installed toolchains
    update         Update Rust toolchains and rustup
    default        Set the default toolchain
    toolchain      Modify or query the installed toolchains
    target         Modify a toolchain's supported targets
    component      Modify a toolchain's installed components
    override       Modify directory toolchain overrides
    run            Run a command with an environment configured for a given toolchain
    which          Display which binary will be run for a given command
    doc            Open the documentation for the current toolchain
    man            View the man page for a given command
    self           Modify the rustup installation
    set            Alter rustup settings
    completions    Generate completion scripts for your shell
    help           Prints this message or the help of the given subcommand(s)
</code></pre>
<h1><a class="header" href="#rustup-1" id="rustup-1">Rustup</a></h1>
<p>The <code>rustup-show</code> command displays active and installed toolchains.</p>
<pre><code class="language-sh">$ rustup show
</code></pre>
<pre><code class="language-plaintext">Default host: x86_64-unknown-linux-gnu

installed toolchains
--------------------

stable-x86_64-unknown-linux-gnu (default)
nightly-2018-01-21-x86_64-unknown-linux-gnu
nightly-x86_64-unknown-linux-gnu

installed targets for active toolchain
--------------------------------------

armv7-unknown-linux-gnueabihf
thumbv7em-none-eabihf
thumbv7m-none-eabi
x86_64-unknown-linux-gnu

active toolchain
----------------

stable-x86_64-unknown-linux-gnu (default)
rustc 1.32.0 (9fda7c223 2019-01-16)
</code></pre>
<h1><a class="header" href="#rustup-2" id="rustup-2">Rustup</a></h1>
<p>You can switch between complier releases with <code>rustup default</code>.</p>
<pre><code class="language-sh">$ rustup default nightly
</code></pre>
<pre><code class="language-plaintext">info: using existing install for 'nightly-x86_64-unknown-linux-gnu'
info: default toolchain set to 'nightly-x86_64-unknown-linux-gnu'

  nightly-x86_64-unknown-linux-gnu unchanged - rustc 1.34.0-nightly (f6fac4225 2019-02-03)
</code></pre>
<pre><code class="language-sh">$ rustup default stable
</code></pre>
<pre><code class="language-plaintext">info: using existing install for 'stable-x86_64-unknown-linux-gnu'
info: default toolchain set to 'stable-x86_64-unknown-linux-gnu'

  stable-x86_64-unknown-linux-gnu unchanged - rustc 1.32.0 (9fda7c223 2019-01-16)
</code></pre>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p>Cargo is Rust's package manager.</p>
<pre><code class="language-sh">$ cargo -h
</code></pre>
<pre><code class="language-plaintext">Rust's package manager

USAGE:
    cargo [OPTIONS] [SUBCOMMAND]

Some common cargo commands are (see all commands with --list):
    build       Compile the current package
    check       Analyze the current package and report errors, but don't build object files
    clean       Remove the target directory
    doc         Build this package's and its dependencies' documentation
    new         Create a new cargo package
    init        Create a new cargo package in an existing directory
    run         Build and execute src/main.rs
    test        Run the tests
    bench       Run the benchmarks
    update      Update dependencies listed in Cargo.lock
    search      Search registry for crates
    publish     Package and upload this package to the registry
    install     Install a Rust binary. Default location is $HOME/.cargo/bin
    uninstall   Uninstall a Rust binary
</code></pre>
<p>Cargo was originally influenced by npm and bundler.</p>
<h1><a class="header" href="#cargo-new" id="cargo-new">Cargo New</a></h1>
<p>Cargo new creates a new Rust package.</p>
<pre><code class="language-sh">$ cargo new -h
</code></pre>
<pre><code class="language-plaintext">cargo-new
Create a new cargo package at path

USAGE:
    cargo new [OPTIONS] path

OPTIONS:
        --registry  REGISTRY     Registry to use
        --vcs VCS                Initialize a new repository for the given version control system (git, hg, pijul, or
                                 fossil) or do not initialize any version control at all (none), overriding a global
                                 configuration. [possible values: git, hg, pijul, fossil, none]
        --bin                    Use a binary (application) template [default]
        --lib                    Use a library template
        --edition YEAR           Edition to set for the crate generated [possible values: 2015, 2018]
        --name NAME              Set the resulting package name, defaults to the directory name
    -v, --verbose                Use verbose output (-vv very verbose/build.rs output)
    -q, --quiet                  No output printed to stdout
        --color WHEN             Coloring: auto, always, never
        --frozen                 Require Cargo.lock and cache are up to date
        --locked                 Require Cargo.lock is up to date
    -Z  FLAG...                  Unstable (nightly-only) flags to Cargo, see 'cargo -Z help' for details
    -h, --help                   Prints help information
</code></pre>
<h1><a class="header" href="#new-crate" id="new-crate">New crate</a></h1>
<h1><a class="header" href="#cargotoml" id="cargotoml">Cargo.toml</a></h1>
<h1><a class="header" href="#cargo-build" id="cargo-build">cargo build</a></h1>
<h1><a class="header" href="#cargolock" id="cargolock">Cargo.lock</a></h1>
<h1><a class="header" href="#cargo-run" id="cargo-run">Cargo Run</a></h1>
<h1><a class="header" href="#cargo-run-release" id="cargo-run-release">Cargo Run Release</a></h1>
<h1><a class="header" href="#rust-workshop-part-ii" id="rust-workshop-part-ii">Rust Workshop: Part II</a></h1>
<h2><a class="header" href="#common-programming-concepts" id="common-programming-concepts">Common Programming Concepts</a></h2>
<h1><a class="header" href="#last-time" id="last-time">Last Time</a></h1>
<ul>
<li>What <em>is</em> Rust?</li>
<li>A Brief history</li>
<li>Overview of the ecosystem</li>
<li>An introduction to <code>Rustup</code> and <code>Cargo</code></li>
<li>Built hello world!</li>
</ul>
<h1><a class="header" href="#today" id="today">Today</a></h1>
<ul>
<li>Variables and Mutability</li>
<li>Data types</li>
<li>Functions</li>
<li>Comments</li>
<li>Control flow</li>
<li>Building a CLI tool: Part 1</li>
</ul>
<h1><a class="header" href="#quote" id="quote">Quote</a></h1>
<p>No quote yet!</p>
<h1><a class="header" href="#keywords" id="keywords">Keywords</a></h1>
<ul>
<li><strong>2015</strong>: as break const continue crate else enum extern false fn for if impl
in let loop match mod move mut pub ref return self Self static struct super
trait true type unsafe use where while</li>
<li><strong>2018</strong>: dyn</li>
<li><strong>Reserved 2015</strong>: abstract become box do final macro override priv typeof
unsized virtual yield</li>
<li><strong>Reserved 2018</strong>: async await try</li>
</ul>
<h1><a class="header" href="#identifiers" id="identifiers">Identifiers</a></h1>
<p>Identifiers are names for variables, functions, structs, etc...</p>
<p>Here are some examples:</p>
<ul>
<li><code>a_var</code> is valid.</li>
<li><code>_var2</code> is valid.</li>
<li><code>3var</code> is not valid.</li>
</ul>
<h1><a class="header" href="#variables" id="variables">Variables</a></h1>
<p>Variables in Rust are <strong>immutable</strong> by default.</p>
<p><em>All</em> variables have a type known at compile time.</p>
<p>Rust has <em>Type Inference</em>. This enables us to omit type annotations.</p>
<pre><code class="language-rust ignore">fn main() {
    let x = 7;
    x = 8;
}
</code></pre>
<pre><code class="language-plaintext">$ cargo run
   Compiling test-rs v0.1.0 (/home/mv/dev/test-rs)
error[E0384]: cannot assign twice to immutable variable `x`
--&gt; src/main.rs:3:5
  |
2 |     let x = 7;
  |         -
  |         |
  |         first assignment to `x`
  |         help: make this binding mutable: `mut x`
3 |     x = 8;
  |     ^^^^^ cannot assign twice to immutable variable

error: aborting due to previous error
</code></pre>
<h1><a class="header" href="#variables-1" id="variables-1">Variables</a></h1>
<p>In Rust, we have to explicitly add the <code>mut</code> keyword to make a variable
mutable.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let mut x = 7;
  x = 8;
}
</code></pre></pre>
<p>In this particular example, we some warnings:</p>
<pre><code class="language-plaintext">$ cargo run
   Compiling test-rs v0.1.0 (/home/mv/dev/test-rs)
warning: variable `x` is assigned to, but never used
 --&gt; src/main.rs:2:13
  |
2 |     let mut x = 7;
  |             ^
  |
  = note: #[warn(unused_variables)] on by default
  = note: consider using `_x` instead

warning: value assigned to `x` is never read
 --&gt; src/main.rs:3:5
  |
3 |     x = 8;
  |     ^
  |
  = note: #[warn(unused_assignments)] on by default
</code></pre>
<h1><a class="header" href="#variables-2" id="variables-2">Variables</a></h1>
<p>Let's add <code>_</code> to our variable to tell the compiler that it is currently unused.</p>
<p>Using <code>_</code> is useful in situations where we <em>may</em> want to act on a value later.
For now, however, it is ignored.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut _x = 7;
    _x = 8;
}
</code></pre></pre>
<pre><code class="language-plaintext">$ cargo run
 Compiling test-rs v0.1.0 (/home/mv/dev/test-rs)
  Finished dev [unoptimized + debuginfo] target(s) in 0.19s
   Running `target/debug/test-rs`
</code></pre>
<p>Success!</p>
<h1><a class="header" href="#variable-shadowing" id="variable-shadowing">Variable Shadowing</a></h1>
<p>We can shadow existing variables in a scope:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 7;
    let x = x * x;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<pre><code class="language-plaintext">$ cargo run
 Compiling test-rs v0.1.0 (/home/mv/dev/test-rs)
  Finished dev [unoptimized + debuginfo] target(s) in 0.20s
   Running `target/debug/test-rs`
The value of x is: 49
</code></pre>
<p>We're effectively creating a new variable with the same name.</p>
<h1><a class="header" href="#variables-and-types" id="variables-and-types">Variables and Types</a></h1>
<p>When declared, variables are assigned a type.</p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = &quot;This is a `&amp;str` type&quot;;
    s = s.len();
}
</code></pre>
<p>You cannot assign mismatch types when assigning variables.</p>
<pre><code class="language-plaintext">$ cargo run
   Compiling test-rs v0.1.0 (/home/mv/dev/test-rs)
error[E0308]: mismatched types
 --&gt; src/main.rs:3:9
  |
3 |     s = s.len();
  |         ^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
    found type `usize`
</code></pre>
<h1><a class="header" href="#data-types" id="data-types">Data Types</a></h1>
<p>Every value in Rust has a type.</p>
<p>Rust is a <em>statically typed</em> language: types are checked at compile time
<em>instead</em> of runtime.</p>
<p>The Rust compiler must know the types of all variables at compile time.</p>
<h1><a class="header" href="#scalars" id="scalars">Scalars</a></h1>
<p>There are several primitive scalar types in Rust:</p>
<table><thead><tr><th>Length</th><th>Rust Signed</th><th>Rust Unsigned</th><th>C Signed</th><th>C Unsigned</th></tr></thead><tbody>
<tr><td>8-Bit</td><td><code>i8</code></td><td><code>u8</code></td><td><code>int8_t</code></td><td><code>uint8_t</code></td></tr>
<tr><td>16-Bit</td><td><code>i16</code></td><td><code>u16</code></td><td><code>int16_t</code></td><td><code>uint16_t</code></td></tr>
<tr><td>32-Bit</td><td><code>i32</code></td><td><code>u32</code></td><td><code>int32_t</code></td><td><code>uint32_t</code></td></tr>
<tr><td>64-Bit</td><td><code>i64</code></td><td><code>u64</code></td><td><code>int64_t</code></td><td><code>uint64_t</code></td></tr>
<tr><td>128-Bit</td><td><code>i128</code></td><td><code>u128</code></td><td>None</td><td>None</td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td><td><code>ssize_t</code><sup class="footnote-reference"><a href="#1">1</a></sup></td><td><code>size_t</code><sup class="footnote-reference"><a href="#1">1</a></sup></td></tr>
</tbody></table>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Sort of...</p>
</div>
<h1><a class="header" href="#integer-literals" id="integer-literals">Integer Literals</a></h1>
<table><thead><tr><th>Number Literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>23_244</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1010_0101</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'R'</code></td></tr>
</tbody></table>
<h1><a class="header" href="#others" id="others">Others</a></h1>
<table><thead><tr><th>Type</th><th>Example</th></tr></thead><tbody>
<tr><td><code>f32</code></td><td><code>let x: f32 = 32.0;</code></td></tr>
<tr><td><code>f64</code></td><td><code>let x: f64 = 64.0;</code></td></tr>
<tr><td><code>bool</code></td><td><code>let b = true;</code></td></tr>
<tr><td><code>char</code></td><td><code>let c = 'z';</code></td></tr>
<tr><td><code>char</code></td><td><code>let c = '';</code></td></tr>
</tbody></table>
<h1><a class="header" href="#type-annotations" id="type-annotations">Type Annotations</a></h1>
<p>Sometimes types cannot be inferred.</p>
<p>In that case, we must <em>annotate</em> types.</p>
<p>For example, we can annotate floats:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 6.4;      // f64 by default

let x: f32 = 3.2; // f32 annotated
#}</code></pre></pre>
<p>Typically, we should always rely on type inference unless we <em>must</em> annotate
types.</p>
<h1><a class="header" href="#type-annotations-1" id="type-annotations-1">Type Annotations</a></h1>
<p>Let's consider another case where we need to parse a string as an integer.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
  let number = &quot;21&quot;.parse().expect(&quot;Not a number!&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#type-annotations-2" id="type-annotations-2">Type Annotations</a></h1>
<p>We can fix this example by adding a type annotation for the integer type we
wish to convert the string into.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number: u32 = &quot;21&quot;.parse().expect(&quot;Not a number!&quot;);
    assert_eq!(21, number);
}
</code></pre></pre>
<h1><a class="header" href="#numeric-casting" id="numeric-casting">Numeric Casting</a></h1>
<p>In specific situations, we can cast between integer types.</p>
<p>For example, we can cast an <code>i32</code> to an <code>i64</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i32 = 5;

let y = x as i64;
#}</code></pre></pre>
<p>We can also do these casts:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let one = true as u8;
let at_sign = 64 as char;
let two_hundred = -56i8 as u8;
#}</code></pre></pre>
<h1><a class="header" href="#numeric-casting-1" id="numeric-casting-1">Numeric Casting</a></h1>
<p>It's important to be careful when casting integer types:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let x: u64 = 0x1_0000_0002;
  let y = x as u32;
  assert_eq!(2, y);
}
</code></pre></pre>
<p>In this case, a truncation occurs and the <code>assert_eq</code> is valid.</p>
<h1><a class="header" href="#side-note-clippy-example" id="side-note-clippy-example">Side Note: Clippy Example</a></h1>
<p>Clippy is Rust's auto formatting tool.</p>
<pre><code class="language-sh">$ cargo clippy
</code></pre>
<p>In the last example, Clippy can help us catch mis-formatted integers:</p>
<pre><code class="language-plaintext">    checking test-rs v0.1.0 (/home/mv/dev/test-rs)
warning: long literal lacking separators
 --&gt; src/main.rs:2:18
  |
2 |     let x: u64 = 0x100000002;
  |                  ^^^^^^^^^^^ help: consider: `0x0001_0000_0002`
  |
  = note: #[warn(clippy::unreadable_literal)] on by default
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#unreadable_literal
</code></pre>
<h1><a class="header" href="#compound-types" id="compound-types">Compound Types</a></h1>
<p>There are two <em>compound types</em> in Rust: tuples and arrays.</p>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>Tuples can contain mixed types and cannot grow or shrink.</p>
<p>We can created fixed tuples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tuple: (i8, f32, u16) = (1, 1.5, 2);
#}</code></pre></pre>
<p>We can <em>deconstruct</em> tuples:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tuple: (i8, f32, u16) = (1, 1.5, 2);
let (a, b, c) = tuple;
#}</code></pre></pre>
<p>We can <em>copy</em> out elements:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tuple: (i8, f32, u16) = (1, 1.5, 2);
let signed8 = tuple.0;
let float32 = tuple.1;
let unsigned16 = tuple.2;
#}</code></pre></pre>
<h1><a class="header" href="#arrays" id="arrays">Arrays</a></h1>
<p>Arrays in Rust are fixed in length and every value in an array has the same
type.</p>
<p>We can declare an array of values of the same type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Also, we can declare an array with a <em>type annotation</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: [u8; 5] = [1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>We can access elements:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3, 4, 5];
let first = a[0];
#}</code></pre></pre>
<h1><a class="header" href="#arrays-1" id="arrays-1">Arrays</a></h1>
<p>But, what happens when...</p>
<pre><pre class="playpen"><code class="language-rust should_panic">fn main() {
  let a = [1, 2, 3, 4, 5];
  let index = 10;
  let element = a[index];

  println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre></pre>
<h1><a class="header" href="#arrays-2" id="arrays-2">Arrays</a></h1>
<p>As a bonus, what happens when...</p>
<pre><code class="language-rust ignore">fn main() {
  let a = [1, 2, 3];
  let end_plus_1 = a[3];
}
</code></pre>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>Like many other programming languages, Rust lets users define functions.</p>
<p>The <code>fn</code> keyword signifies a function declaration:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  another_function();
}

fn another_function() {
  println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#parameters" id="parameters">Parameters</a></h1>
<p>Functions can take <em>paramters</em>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  another_function(10);
}

fn another_function(x: u32) {
  println!(&quot;Another function: x = {}.&quot;, x);
}
</code></pre></pre>
<p><em>Type annotations</em> for parameters are required!</p>
<h1><a class="header" href="#definitions" id="definitions">Definitions</a></h1>
<p>A <em>statement</em> is an instruction that performs some action and does not return a
value.</p>
<p>An <em>expression</em> evaluates to a value.</p>
<p>For example, the following is an expression that contains a statement:</p>
<pre><code class="language-rust ignore">{
  let x = 3;
  x + 1
}
</code></pre>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<p>Calling a function is an <em>expression</em>.</p>
<p>Calling a macro is an <em>expression</em>.</p>
<p>The block used to create new scopes <code>{}</code> is an <em>expression</em>.</p>
<p>Rust is an expression-based language.</p>
<h1><a class="header" href="#expressions-1" id="expressions-1">Expressions</a></h1>
<p>As an example, the function below contains an expression.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let x = 5;
  let y = {
    let x = 3;
    x + 1
  };

  println!(&quot;The value of x is: {}&quot;, x);
  println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<h1><a class="header" href="#return-values" id="return-values">Return Values</a></h1>
<p>Functions can also return value. The return type is written to the right of
<code>-&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let x = pow_2(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn pow_2(x: u32) -&gt; u32 {
    x * x
}
</code></pre></pre>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<pre><code class="language-rust ignore">// this is a comment!
</code></pre>
<pre><code class="language-rust ignore">fn main() {
  println!(&quot;hello&quot;); // this is a comment!
}
</code></pre>
<pre><code class="language-rust ignore">fn main() {
  // this is a comment!
  println!(&quot;hello&quot;);
}
</code></pre>
<pre><code class="language-rust ignore">fn main() {
  /*
    This is a multi-line comment!
  */
  println!(&quot;hello&quot;);
}
</code></pre>
<h1><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h1>
<p>Rust includes familiar control flow keywords like <code>if</code>, <code>else</code>, <code>while</code> and
<code>for</code>.</p>
<p>As opposed to C, there some additional keywords and patterns for control flow
like <code>loop</code> and <code>if</code> in a <code>let</code> statement that are commonly used.</p>
<h1><a class="header" href="#if-and-else" id="if-and-else">If and Else</a></h1>
<p><code>if</code> and <code>else</code> statements behave similarly to C:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<h1><a class="header" href="#if-in-a-let-statement" id="if-in-a-let-statement"><code>if</code> in a <code>let</code> Statement</a></h1>
<p>Does this compile correctly?</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };
    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<h1><a class="header" href="#if-in-a-let-statement-1" id="if-in-a-let-statement-1"><code>if</code> in a <code>let</code> Statement</a></h1>
<p>Does this compile correctly?</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        &quot;Six&quot;
    };
    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<h1><a class="header" href="#loops" id="loops">Loops</a></h1>
<p>Rust includes the <code>loop</code> keyword for infinite loops:</p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
        // We could `continue`, `break` or `return` here!
    }
}
</code></pre>
<h1><a class="header" href="#loops-1" id="loops-1">Loops</a></h1>
<p>We can break from loops and use them as an expression:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<h1><a class="header" href="#while-loops" id="while-loops"><code>while</code> Loops</a></h1>
<p><code>while</code> loops also work similarly to C.</p>
<p>Let's write a countdown:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [5, 4, 3, 2, 1];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;{} &quot;, a[index]);

        index += 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#for-loops" id="for-loops"><code>for</code> Loops</a></h1>
<p>We can adjust our countdown code slightly to use a <code>for</code> loop:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [5, 4, 3, 2, 1];

    for number in a.iter() {
        println!(&quot;{} &quot;, number);
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#for-loops-1" id="for-loops-1"><code>for</code> Loops</a></h1>
<p>Finally, we can use a range to iterate over:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..6).rev() {
        println!(&quot;{} &quot;, number);
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#rust-workshop-part-iii" id="rust-workshop-part-iii">Rust Workshop: Part III</a></h1>
<h2><a class="header" href="#ownership" id="ownership">Ownership</a></h2>
<h1><a class="header" href="#last-time-1" id="last-time-1">Last Time</a></h1>
<ul>
<li>Variables and Mutability</li>
<li>Data types</li>
<li>Functions</li>
<li>Comments</li>
<li>Control flow</li>
<li><code>emoji-fzf</code>: Part 1</li>
</ul>
<h1><a class="header" href="#today-1" id="today-1">Today</a></h1>
<ul>
<li>What is Ownership?</li>
<li>References and Borrowing</li>
<li>Slices</li>
<li><code>emoji-fzf</code>: Part 2</li>
</ul>
<h1><a class="header" href="#quote-1" id="quote-1">Quote</a></h1>
<blockquote>
<p>Ownership is hard.</p>
<p>It indeed is. And you managed to do that exact hard
thing by hand, without any mechanical checks. (Or so you think.)</p>
<p> @Cryolite on <a href="https://twitter.com/Cryolite/status/1104325100881375232">twitter</a> (translated from Japanese)</p>
</blockquote>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Originally, Rust used to have a garbage collector.</p>
<p>Turns out, you <em>don't need</em> a garbage collector for memory safety.</p>
<h1><a class="header" href="#stack-and-heap" id="stack-and-heap">Stack and Heap</a></h1>
<p>To refresh, we have the following in C:</p>
<pre><code class="language-c">int main() {
  // Allocate an integer on the heap
  // `ptr` is stack local
  int *ptr = (int *) malloc(sizeof(int));
  // Do some stuff with `ptr`
  free(ptr);
}
</code></pre>
<p>Like C, Rust allocate everything on the stack by default.</p>
<p>With the Rust standard library, we can allocate data on the heap.</p>
<h1><a class="header" href="#ownership-rules" id="ownership-rules">Ownership Rules</a></h1>
<ul>
<li>Each <em>value</em> in Rust has a <em>variable</em> that's called its <em>owner</em>.</li>
<li>There can only be one owner for a value at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<h1><a class="header" href="#variable-scopes" id="variable-scopes">Variable Scopes</a></h1>
<p>An example of <em>ownership</em>:</p>
<pre><code class="language-rust ignore">{ // s is not valid here, its not yet declared
  let s = &quot;hey&quot;;  // s is valid from this point forward
  // do stuff with s
} // this scope is now over, and s is no longer valid
</code></pre>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>We can create a new <code>String</code> type by using <code>::</code> to call a namespaced function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);
#}</code></pre></pre>
<p>We can mutate <code>String</code>s by calling a function on the type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);
// push_str() appends a literal to a String
s.push_str(&quot;, world!&quot;);
println!(&quot;{}&quot;, s); // This will print `hello, world!`
#}</code></pre></pre>
<p>We <em>cannot</em> mutate <code>&amp;str</code> types. Weird.</p>
<h1><a class="header" href="#str-and-string" id="str-and-string"><code>&amp;str</code> and <code>String</code></a></h1>
<p>The content of a string literal is known at compile time.</p>
<p>This makes it fast, but also immutable!</p>
<p><code>String</code>s on the other hand, need to be mutable and growable.</p>
<p><code>String</code>s in Rust use the heap!</p>
<h1><a class="header" href="#a-heap-allocated-string" id="a-heap-allocated-string">A Heap Allocated <code>String</code></a></h1>
<p>Heap memory must be requested from the OS.</p>
<p>We need a way to return back the memory to the OS when done.</p>
<pre><code class="language-rust ignore">// `::from` calls `malloc()`
let mut s = String::from(&quot;hello&quot;);
</code></pre>
<p>... but we need to call <code>free()</code>!</p>
<h1><a class="header" href="#raii" id="raii">RAII</a></h1>
<p>RAII stands for: <em>Resource Acquisition is Initialization</em>.</p>
<p>When a <code>String</code> goes out of scope, a <code>drop</code> function is called.</p>
<pre><code class="language-rust ignore">{
  let s = String::from(&quot;hello&quot;); // s is valid
  // do stuff with s
} // Scope is over, `s` is no longer valid, `drop` is called
</code></pre>
<p>Informally, ownership is lexically scoped.</p>
<h1><a class="header" href="#ways-variables-and-data-interact" id="ways-variables-and-data-interact">Ways Variables and Data Interact</a></h1>
<p>There are two primary ways variables and data interact: <code>move</code> and <code>copy</code>.</p>
<h1><a class="header" href="#ways-variable-and-data-interact-move" id="ways-variable-and-data-interact-move">Ways Variable and Data Interact: Move</a></h1>
<p>When we assign integers, data is copied on the stack:</p>
<pre><code class="language-rust ignore">let x = 5;
let y = x;  // Copy the value of x to y
// There now two `5`s on the stack
</code></pre>
<p>This is different than <code>String</code>s. For example:</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
</code></pre>
<p>Are there <em>two</em> strings now?</p>
<h1><a class="header" href="#ways-variable-and-data-interact-move-1" id="ways-variable-and-data-interact-move-1">Ways Variable and Data Interact: Move</a></h1>
<p>A <code>String</code> has data on both the stack (left) and the heap (right).</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-01.svg" alt="String memory" /></p>
<h1><a class="header" href="#ways-variable-and-data-interact-move-2" id="ways-variable-and-data-interact-move-2">Ways Variable and Data Interact: Move</a></h1>
<p><code>String</code>'s are similar to this in C:</p>
<pre><code class="language-c">//! A 'safe' String :)
typedef struct {
  void *p;     //! Points at the real data
  size_t len;  //! Current length
  size_t cap;  //! Total capacity
} sString
</code></pre>
<p>(I may have written this once)</p>
<h1><a class="header" href="#ways-variable-and-data-interact-move-3" id="ways-variable-and-data-interact-move-3">Ways Variable and Data Interact: Move</a></h1>
<p>Back to our example, what happens when we assign <code>s1</code> to <code>s2</code>..</p>
<pre><code class="language-rust ignore">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
</code></pre>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-02.svg" alt="String assignment" /></p>
<p>When we assign <code>s1</code> to <code>s2</code>, we only copy the data on the stack. We do not copy
the heap data.</p>
<h1><a class="header" href="#ways-variable-and-data-interact-move-4" id="ways-variable-and-data-interact-move-4">Ways Variable and Data Interact: Move</a></h1>
<p>What if we made a 'deep' copy?</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-03.svg" alt="String assignment" /></p>
<p>Making deep copies of data is inefficient if the <code>String</code> capacity is large!</p>
<h1><a class="header" href="#ways-variable-and-data-interact-move-5" id="ways-variable-and-data-interact-move-5">Ways Variable and Data Interact: Move</a></h1>
<p>Back to our example, what happens if we try to use <code>s1</code> after moving?</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
println!(&quot;{} world!&quot;, s1);
#}</code></pre></pre>
<h1><a class="header" href="#ways-variable-and-data-interact-move-6" id="ways-variable-and-data-interact-move-6">Ways Variable and Data Interact: Move</a></h1>
<p><code>s1</code> is invalidated after <em>move</em> to <code>s2</code>:</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-04.svg" alt="Move invalidation" /></p>
<p>Eventually, when <code>s2</code> goes out of scope, it is freed! (not <code>s1</code>)</p>
<h1><a class="header" href="#ways-variable-and-data-interact-move-7" id="ways-variable-and-data-interact-move-7">Ways Variable and Data Interact: Move</a></h1>
<p>To recap, a <em>move</em>:</p>
<ul>
<li>Performs a shallow copy</li>
<li>Invalidates the original variable</li>
<li>Transfers ownership of the value to the new variable</li>
</ul>
<p>By default, Rust will never make 'deep' copies.</p>
<p><em>Automatic</em> is assumed to be cheap in Rust!</p>
<h1><a class="header" href="#ways-variable-and-interact-clone" id="ways-variable-and-interact-clone">Ways Variable and Interact: Clone</a></h1>
<p>Sometimes, we may want to make a 'deep' copy.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();
println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
#}</code></pre></pre>
<p>There are now two <code>String</code>s on the heap!</p>
<h1><a class="header" href="#stack-only-data-copy" id="stack-only-data-copy">Stack-Only Data: Copy</a></h1>
<p>For simple data, we say the type is <code>copy</code> instead of <code>clone</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
#}</code></pre></pre>
<h1><a class="header" href="#other-copy-types" id="other-copy-types">Other Copy Types</a></h1>
<p>Here are a few copy types:</p>
<ul>
<li>All integer types: ex. <code>u32</code></li>
<li>Booleans: <code>bool</code></li>
<li>All floating point types: <code>f32</code>, <code>f64</code></li>
<li>The character type, <code>char</code></li>
<li>Tuples, if they <em>only</em> contain types that are <code>copy</code></li>
<li>For example, <code>(f32, bool)</code> is <code>copy</code>, but <code>(f32, String)</code> is not.</li>
</ul>
<h1><a class="header" href="#ownership-and-functions" id="ownership-and-functions">Ownership and Functions</a></h1>
<p>How does ownership relate to functions?</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let s = String::from(&quot;hello&quot;);
  takes_ownership(s);

  let x = 5;
  makes_copy(x);
}

fn takes_ownership(s: String) {
  println!(&quot;{}&quot;, s);
} // String `s` is `drop`ed here

fn makes_copy(x: u32) {
  println!(&quot;{}&quot;, x);
} // Nothing happens to `x` here, it was on the stack
</code></pre></pre>
<h1><a class="header" href="#return-values-and-scope" id="return-values-and-scope">Return Values and Scope</a></h1>
<p>Consider this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let s = gives_ownership();
  let s = takes_then_gives_ownership(s);
  takes_ownership(s);
}

fn gives_ownership() -&gt; String {
  String::from(&quot;hello&quot;)
}

fn takes_then_gives_ownership(s: String) -&gt; String {
  s
}

fn takes_ownership(s: String) {
  println!(&quot;{}&quot;, s);
} // String `s` is `drop`ed here
</code></pre></pre>
<p>This prints <code>hello</code>! However, this is kinda tedious carrying around ownership
all the time!</p>
<h1><a class="header" href="#ownership-can-be-tedious" id="ownership-can-be-tedious">Ownership can be Tedious!</a></h1>
<p>For a clearer example of where ownership is tedious, consider this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
 let s1 = String::from(&quot;hello&quot;);
 let (s2, len) = calculate_length(s1);
 println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
  let length = s.len(); // len() returns the length of a String
  (s, length)
}
</code></pre></pre>
<p>We don't need to take ownership to <code>calculate_length</code>!</p>
<h1><a class="header" href="#references-and-borrowing" id="references-and-borrowing">References and Borrowing</a></h1>
<p>We can use a reference to the <code>String</code> instead!</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let s1 = String::from(&quot;hello&quot;);
  let len = calculate_length(&amp;s1);
  println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
  s.len()
}
</code></pre></pre>
<p>We can take a reference using <code>&amp;</code>.</p>
<h1><a class="header" href="#references-and-borrowing-1" id="references-and-borrowing-1">References and Borrowing</a></h1>
<p><em>References</em> allow you to refer to a value without taking ownership.</p>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-05.svg" alt="References" /></p>
<p>There is a dereference operator <code>*</code> that we'll talk about later.</p>
<h1><a class="header" href="#references-and-borrowing-2" id="references-and-borrowing-2">References and Borrowing</a></h1>
<p>What is actually happening when we call <code>calculate_length</code>?</p>
<pre><code class="language-rust ignore">// `s` is a reference to a string
fn calculate_length(s: &amp;String) -&gt; usize {
  s.len()
} // When `s` goes out of scope, nothing happens because
  // because a reference does not have ownership of
  // values
</code></pre>
<p>Having references as function parameters is called <em>borrowing</em>.</p>
<h1><a class="header" href="#mutable-references" id="mutable-references">Mutable References</a></h1>
<p>What happens when we try to mutate a reference?</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
  let s = String::from(&quot;hello&quot;);
  change(&amp;s);
}

fn change(some_string: &amp;String) {
  some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#mutable-references-1" id="mutable-references-1">Mutable References</a></h1>
<p>Let's fix our example by using <code>mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let mut s = String::from(&quot;hello&quot;);
  change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
  some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#mutable-references-2" id="mutable-references-2">Mutable References</a></h1>
<p>But, what happens when we try to change the same <code>String</code> twice?</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
  let mut s = String::from(&quot;hello&quot;);
  let mut s1 = &amp;mut s;
  let mut s2 = &amp;mut s;
  change(&amp;mut s1);
  change(&amp;mut s2);
}

fn change(some_string: &amp;mut String) {
  some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#mutable-references-3" id="mutable-references-3">Mutable References</a></h1>
<p>You can only have 1 mutable reference at a time!</p>
<p>This restriction helps prevent <em>data races</em> at compile time!</p>
<p>The benefit of having this restriction is that Rust can prevent data races at
compile time. A data race is similar to a race condition and happens when these
three behaviors occur:</p>
<ul>
<li>Two or more pointers access the same data at the same time.</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>Theres no mechanism being used to synchronize access to the data.</li>
</ul>
<h1><a class="header" href="#multiple-mutable-references" id="multiple-mutable-references">Multiple Mutable References</a></h1>
<p>You can have multiple mutable references, just not simultaneous ones:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);
{
  let r1 = &amp;mut s;
  println!(&quot;{}&quot;, r1);
} // r1 goes out of scope here..
  // We can make a new reference with no problems.
let r2 = &amp;mut s;
println!(&quot;{}&quot;, r2);
#}</code></pre></pre>
<h1><a class="header" href="#briefly-non-lexical-lifetimes" id="briefly-non-lexical-lifetimes">Briefly: Non-Lexical Lifetimes</a></h1>
<p>Non-Lexical Lifetimes (NLL) was a recent change in the Rust compiler to make
the borrow checker more correct.</p>
<p>Lifetimes are now based on the control flow graph rather than lexical scopes.</p>
<p>Some of the borrow checker examples that previously did not compile, are now
ok!</p>
<h1><a class="header" href="#the-borrow-checker-in-rust-2015" id="the-borrow-checker-in-rust-2015">The Borrow Checker in Rust 2015</a></h1>
<p>In Rust 2015, this example does not compile:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    let r1 = &amp;mut s;     // 'lifetime of `r1` --+
    println!(&quot;{}&quot;, r1);  //                     |
                         //                     |
    let r2 = &amp;mut s;     // 'lifetime of `r2` --|-+
    println!(&quot;{}&quot;, r2)   //                     | |
} // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+-+
</code></pre>
<pre><code class="language-plaintext">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:7:19
  |
4 |     let r1 = &amp;mut s;
  |                   - first mutable borrow occurs here
...
7 |     let r2 = &amp;mut s;
  |                   ^ second mutable borrow occurs here
8 |     println!(&quot;{}&quot;, r2)
9 | }
</code></pre>
<p>You cannot have two mutable borrows in the same lexical scope.</p>
<h1><a class="header" href="#the-borrow-checker-in-rust-2018" id="the-borrow-checker-in-rust-2018">The Borrow Checker in Rust 2018</a></h1>
<p>The borrow check now behaves like this:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut s = String::from(&quot;hello&quot;);
    let r1 = &amp;mut s;     // 'lifetime of `r1` --+
    println!(&quot;{}&quot;, r1);  //                     |
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+

    let r2 = &amp;mut s;     // 'lifetime of `r2` --+
    println!(&quot;{}&quot;, r2)   //                     |
//  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+
}
</code></pre>
<pre><code class="language-plaintext">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/test-rs`
hello
hello
</code></pre>
<h1><a class="header" href="#mixed-mutable-references" id="mixed-mutable-references">Mixed Mutable References</a></h1>
<p>What happens if we mix immutable and mutable references?</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
# #![allow(unused_variables)]
#fn main() {
let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // no problem
let r2 = &amp;s; // no problem
let r3 = &amp;mut s; // BIG PROBLEM

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3)
#}</code></pre></pre>
<p>We <em>cannot</em> have a mutable reference while we have an immutable one!</p>
<p>This could lead to <em>data races</em>!</p>
<h1><a class="header" href="#dangling-pointers" id="dangling-pointers">Dangling Pointers</a></h1>
<p>In C, it is possible for us to write:</p>
<pre><code class="language-c">int main() {
  int *p = (int *) malloc(sizeof(int));
  free(p);
  printf(&quot;%d&quot;, *p);  // Uh oh!
}
</code></pre>
<p>How does Rust handle this case?</p>
<h1><a class="header" href="#dangling-references" id="dangling-references">Dangling References</a></h1>
<p>Rust prevents dangling references at compile time!</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);
    &amp;s
}
</code></pre></pre>
<h1><a class="header" href="#rules-of-references" id="rules-of-references">Rules of References</a></h1>
<p>In summary:</p>
<ul>
<li>At any given time, you can either have one mutable reference or any number of
immutable references.</li>
<li>References must always be valid.</li>
</ul>
<h1><a class="header" href="#slices" id="slices">Slices</a></h1>
<p>This is another data type that does not have ownership.</p>
<p>A <em>slice</em> references a contiguous sequence of elements in a collection rather
than the whole collection.</p>
<p>It is a type of reference.</p>
<h1><a class="header" href="#string-slices" id="string-slices">String Slices</a></h1>
<p>Here's a quick example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);
let hello = &amp;s[0..5];
let world = &amp;s[6..11];
#}</code></pre></pre>
<p>Or alternatively:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);
let hello = &amp;s[0..=4];
let world = &amp;s[6..=10];
#}</code></pre></pre>
<p>Or even:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = String::from(&quot;hello world&quot;);
let hello = &amp;s[..=4];
let world = &amp;s[6..];
#}</code></pre></pre>
<p>For string slices, we assume ASCII. UTF-8 slices on partial chars will panic.
Slices follow the same borrowing rules as references.</p>
<h1><a class="header" href="#string-slices-1" id="string-slices-1">String Slices</a></h1>
<p><img src="https://doc.rust-lang.org/book/img/trpl04-06.svg" alt="String slice" /></p>
<h1><a class="header" href="#string-literal-slices" id="string-literal-slices">String Literal Slices</a></h1>
<p>This slice points to a specific point in the binary:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;str = &quot;hello world&quot;;
#}</code></pre></pre>
<p><code>&amp;str</code> is immutable because it's an immutable reference!</p>
<h1><a class="header" href="#other-slices" id="other-slices">Other Slices</a></h1>
<p>There are other types of slices as well.</p>
<p>Here is a <code>&amp;[i32]</code> slice:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a: [i32; 5] = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
#}</code></pre></pre>
<h1><a class="header" href="#recap" id="recap">Recap</a></h1>
<p><strong>Ownership</strong></p>
<ul>
<li>Each <em>value</em> in Rust has a <em>variable</em> that's called its <em>owner</em>.</li>
<li>There can only be one owner for a value at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<p><strong>References</strong></p>
<ul>
<li>At any given time, you can either have one mutable reference or any number of
immutable references.</li>
<li>References must always be valid.</li>
</ul>
<h1><a class="header" href="#rust-workshop-part-iv" id="rust-workshop-part-iv">Rust Workshop: Part IV</a></h1>
<h2><a class="header" href="#structs-enums-and-crates" id="structs-enums-and-crates">Structs, Enums and Crates</a></h2>
<h1><a class="header" href="#last-time-2" id="last-time-2">Last Time</a></h1>
<ul>
<li>What is Ownership?</li>
<li>References and Borrowing</li>
<li>Slices</li>
<li><code>emoji-fzf</code>: Part 2</li>
</ul>
<h1><a class="header" href="#today-2" id="today-2">Today</a></h1>
<ul>
<li>Structs</li>
<li>Method Syntax</li>
<li>Enums</li>
<li>Matches</li>
<li>Packages, Crates, Modules</li>
<li>Visibility Modifiers</li>
<li><code>emoji-fzf</code>: Part 3</li>
</ul>
<h1><a class="header" href="#quote-2" id="quote-2">Quote</a></h1>
<blockquote>
<p>&amp;T means its borrowed, and T means its owned, and you cant take ownership
of a thing youve borrowed  Rust doesnt support stealing! </p>
<p> kornel on <a href="https://users.rust-lang.org/t/vec-t-to-vec-t/21736/2">rust-users</a></p>
</blockquote>
<h1><a class="header" href="#structs" id="structs">Structs</a></h1>
<h1><a class="header" href="#declaration" id="declaration">Declaration</a></h1>
<p>Declarations are a little different between C and Rust:</p>
<pre><code class="language-c">typedef struct {
    char *name;
    char *path;
    size_t entries;
    bool is_busy;
} sContext;
</code></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Context {
    name: String,
    path: String,
    entries: usize,
    is_busy: bool,
}
#}</code></pre></pre>
<h1><a class="header" href="#instantiation" id="instantiation">Instantiation</a></h1>
<p>We can create a new struct like so:</p>
<pre><code class="language-c">sContext context = {
    .name = &quot;Context&quot;,
    .path = NULL,
    .entries = 0,
    .is_busy = false,
};
</code></pre>
<pre><code class="language-rust ignore">let context = Context {
    name: String::from(&quot;Context&quot;),
    path: String::from(&quot;/home/context&quot;),  // NULL not possible!
    entries: 0,
    is_busy: false,
};
</code></pre>
<p>Note: the internal representation of these structures are not the same even
though they are roughly functionally equivalent.</p>
<h1><a class="header" href="#modification" id="modification">Modification</a></h1>
<p>Both C and Rust have very similar ways of modify struct members:</p>
<pre><code class="language-c">sContext context = {
    .name = &quot;Context&quot;,
    .path = &quot;/home/context&quot;,
    .entries = 0,
    .is_busy = false,
};

context.path = &quot;/var/context&quot;;
</code></pre>
<pre><code class="language-rust ignore">let mut context = Context {
    name: String::from(&quot;Context&quot;),
    path: String::from(&quot;/home/context&quot;),
    entries: 0,
    is_busy: false,
};

context.path = String::from(&quot;/var/context&quot;);
</code></pre>
<h1><a class="header" href="#constructor-short-hand" id="constructor-short-hand">Constructor Short Hand</a></h1>
<p>To reduce verbosity, Rust has a shorthand for constructing structs:</p>
<pre><code class="language-rust ignore">fn new(name: String, path: String) -&gt; Context
    Context {
        name: name,
        path: path,
        entries: 0,
        is_busy: false,
    }
}
</code></pre>
<p>Above is the same as:</p>
<pre><code class="language-rust ignore">fn new(name: String, path: String) -&gt; Context
    Context {
        name,
        path,
        entries: 0,
        is_busy: false,
    }
}
</code></pre>
<h1><a class="header" href="#update-syntax" id="update-syntax">Update Syntax</a></h1>
<p>Rust also has a shorthand for updating structures:</p>
<pre><code class="language-rust ignore">let context1 = Context {
    name: String::from(&quot;Context&quot;),
    path: String::from(&quot;/home/context&quot;),
    entries: 0,
    is_busy: false,
};
</code></pre>
<p>Above is the same as:</p>
<pre><code class="language-rust ignore">let context2 = Context {
    entries: 1,
    ..context1 // `Context1` moved
};
</code></pre>
<h1><a class="header" href="#tuple-structs" id="tuple-structs">Tuple Structs</a></h1>
<p>Tuple structs in Rust are structures composed with unnamed fields:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Rbg(i32, i32, i32);

let black = Rbg(0, 0, 0);
assert_eq!(0, black.0);
#}</code></pre></pre>
<p>This type of structure helps to decrease verbosity in some situations.</p>
<h1><a class="header" href="#unit-structs" id="unit-structs">Unit Structs</a></h1>
<p>A structure with no data is called a <em>unit struct</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct UnitStruct();

let unit_struct = UnitStruct();
#}</code></pre></pre>
<p>This pattern is useful when we need to implement a <em>trait</em> on a type, but have
no data to store.</p>
<h1><a class="header" href="#ownership-and-structs" id="ownership-and-structs">Ownership and Structs</a></h1>
<p>Can structs store references?</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
# #![allow(unused_variables)]
#fn main() {
struct Context {
    name: &amp;str,
    path: &amp;str,
    entries: usize,
    is_busy: bool,
}

let context = Context {
    name: &quot;Context&quot;,
    path: &quot;/home/context&quot;,
    entries: 0,
    is_busy: false,
};
#}</code></pre></pre>
<h1><a class="header" href="#ownership-and-structs-1" id="ownership-and-structs-1">Ownership and Structs</a></h1>
<p>Uh oh!</p>
<pre><code class="language-plaintext">$ cargo build
   Compiling test-rs v0.1.0 (/home/mv/dev/test-rs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:11
  |
3 |     name: &amp;str,
  |           ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:11
  |
4 |     path: &amp;str,
  |           ^ expected lifetime parameter

error: aborting due to 2 previous errors
</code></pre>
<p>They can! We'll come back to this later!</p>
<h1><a class="header" href="#adding-meaning-with-structs" id="adding-meaning-with-structs">Adding Meaning with Structs</a></h1>
<p>There are often many ways a representing data:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 3;
let y = 10;
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let point = (3, 10);
#}</code></pre></pre>
<p>Structs enabled us to be more descriptive about field contents.</p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
  x: usize,
  y: usize,
}

fn main() {
  let _point = Point { x: 3, y: 10 };
}
</code></pre></pre>
<h1><a class="header" href="#adding-functionality-with-derived-traits" id="adding-functionality-with-derived-traits">Adding Functionality with Derived Traits</a></h1>
<p>Often, we would like to display the contents of our structures:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">struct Point {
    x: usize,
    y: usize,
}

fn main() {
    let point = Point { x: 3, y: 10 };
    println!(&quot;{}&quot;, point);
}
</code></pre></pre>
<h1><a class="header" href="#adding-functionality-with-derived-traits-1" id="adding-functionality-with-derived-traits-1">Adding Functionality with Derived Traits</a></h1>
<p>Ouch, let's try the <code>:?</code> formatter instead:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">struct Point {
    x: usize,
    y: usize,
}

fn main() {
    let point = Point { x: 3, y: 10 };
    println!(&quot;{:?}&quot;, point);
}
</code></pre></pre>
<h1><a class="header" href="#adding-functionality-with-derived-traits-2" id="adding-functionality-with-derived-traits-2">Adding Functionality with Derived Traits</a></h1>
<p>Let's 'derive' the <code>Debug</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Point {
    x: usize,
    y: usize,
}

fn main() {
    let point = Point { x: 3, y: 10 };
    println!(&quot;{:?}&quot;, point);
}
</code></pre></pre>
<h1><a class="header" href="#defining-methods" id="defining-methods">Defining Methods</a></h1>
<p>Let's defined the <code>distance</code> method on the <code>Point</code> struct:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Point {
    x: usize,
    y: usize,
}

impl Point {
    fn distance(&amp;self) -&gt; f64 {
        ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt()
    }
}

fn main() {
    let point = Point { x: 5, y: 10 };
    println!(&quot;The distance from the origin is {} units.&quot;,
             point.distance());
}
</code></pre></pre>
<h1><a class="header" href="#where-did---go" id="where-did---go">Where did <code>-&gt;</code> go?</a></h1>
<p>In C/C++ we must keep track of pointers:</p>
<pre><code class="language-c">context.something();
// Or if context is a pointer...
context-&gt;something()
// That desugars to...
(*context).something()
</code></pre>
<h1><a class="header" href="#where-did---go-1" id="where-did---go-1">Where did <code>-&gt;</code> go?</a></h1>
<p>Rust has a feature called <em>automatic referencing and dereferencing</em>:</p>
<pre><code class="language-rust ignore">impl Point {
    fn distance(&amp;self) -&gt; f64 {
        ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt()
    }
}

// The following are the same
point.distance();
(&amp;point).distance();
</code></pre>
<p>The <code>&amp;</code>, <code>&amp;mut</code> or <code>*</code> are added by the compiler to match the signature of the
method.</p>
<h1><a class="header" href="#methods-with-more-parameters" id="methods-with-more-parameters">Methods With More Parameters</a></h1>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Point {
    x: usize,
    y: usize,
}

impl Point {
    fn distance(&amp;self) -&gt; f64 {
        ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt()
    }

    fn is_further_than(&amp;self, other: &amp;Point) -&gt; bool {
        self.distance() &gt; other.distance()
    }
}

fn main() {
    let point = Point { x: 5, y: 10 };
    let other = Point { x: 10, y: 10 };
    println!(&quot;Is {:?} further from the origin than {:?}... {}&quot;,
             point, other, point.is_further_than(&amp;other));
}
</code></pre></pre>
<p>Note that <code>self</code> is never passed in by the caller.</p>
<h1><a class="header" href="#associated-functions" id="associated-functions">Associated Functions</a></h1>
<h1><a class="header" href="#multiple-impl-blocks" id="multiple-impl-blocks">Multiple impl Blocks</a></h1>
<h1><a class="header" href="#recap-1" id="recap-1">Recap</a></h1>
<h1><a class="header" href="#rust-workshop-part-v" id="rust-workshop-part-v">Rust Workshop: Part V</a></h1>
<h2><a class="header" href="#common-collections" id="common-collections">Common Collections</a></h2>
<h1><a class="header" href="#last-time-3" id="last-time-3">Last Time</a></h1>
<ul>
<li>Structs</li>
<li>Method Syntax</li>
<li>Enums</li>
<li>Matches</li>
<li>Packages, Crates, Modules</li>
<li>Visibility Modifiers</li>
<li><code>emoji-fzf</code>: Part 3</li>
</ul>
<h1><a class="header" href="#today-3" id="today-3">Today</a></h1>
<ul>
<li>The Standard Library</li>
<li><code>Vec</code></li>
<li><code>String</code></li>
<li><code>HashMap</code></li>
<li><code>emoji-fzf</code>: Part 4</li>
</ul>
<h1><a class="header" href="#quote-3" id="quote-3">Quote</a></h1>
<blockquote>
<blockquote>
<p>When programmers are saying that there are a lot of bicycles in code that
means that it contains reimplementations of freely available libraries instead
of using them</p>
</blockquote>
<p>Presumably the metric for this would be bicyclomatic complexity?</p>
<p> <a href="https://www.reddit.com/r/rust/comments/6zdvza/my_experience_participating_in_highload_cup_re/dmuoydx/">/u/tomwhoiscontrary on reddit</a></p>
</blockquote>
<h1><a class="header" href="#the-standard-library" id="the-standard-library">The Standard Library</a></h1>
<ul>
<li>The <em>foundation</em> of portable Rust software</li>
<li><code>std</code> is available to all crates by default</li>
<li>Parts of <code>std</code> can be brought into scope via <code>use</code>:
<ul>
<li>ex. <code>use std::env;</code></li>
</ul>
</li>
</ul>
<p>In recent times, the standard library consists of two parts:</p>
<ul>
<li><code>core</code>: A <em>minimal</em> platform dependency free (no heap, no I/O, no concurrency) foundation.</li>
<li><code>std</code>: <code>core</code> plus `platform depenpendent core types.</li>
</ul>
<p><code>core</code> is a subset of <code>std</code>.</p>
<p>We'll circle back on this when we talk about crates without the <code>std</code> library!</p>
<h1><a class="header" href="#a-quick-tour" id="a-quick-tour">A Quick Tour</a></h1>
<ul>
<li>Options and errors: <code>Option&lt;T&gt;</code> and <code>Result&lt;T, E&gt;</code></li>
<li>Iterators: <code>std::iter</code> and the <code>Iterator</code> trait</li>
<li>Contiguous memory regions:
<ul>
<li><code>Vec&lt;T&gt;</code>: A heap-allocated <em>vector</em> that is resizable at runtime.</li>
<li><code>[T; n]</code>: An inline <em>array</em> with a fixed size at compile time.</li>
<li><code>[T]</code>: A dynamically sized slice into any other kind of contiguous storage, whether heap-allocated or not.</li>
</ul>
</li>
<li>Slices
<ul>
<li><code>&amp;[T]</code>: <em>shared slice</em></li>
<li><code>&amp;mut [T]</code>: <em>mutable slice</em></li>
<li><code>Box&lt;T&gt;</code>: <em>owned slice</em></li>
</ul>
</li>
<li>UTF-8 strings: <code>&amp;str</code> and <code>String</code></li>
<li>Utilities for printing <code>String</code>s: <code>std::fmt</code> and associated macros</li>
<li>Data sharing: <code>Rc</code>, <code>Cell</code>, <code>RefCell</code>, <code>Arc</code> and <code>Mutex</code></li>
<li><code>std::collections</code>: maps, sets, linked lists and others.</li>
<li>Platform abstractions and I/O
<ul>
<li>Typically I/O: <code>io</code>, <code>fs</code> and <code>net</code></li>
<li>Threading: <code>thread</code>, <code>sync</code>, <code>atomic</code>, <code>mpsc</code></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#collection-types" id="collection-types">Collection Types</a></h1>
<p>Collections fall into four major categories:</p>
<ul>
<li>Sequences: <code>Vec</code>, <code>VecDeque</code>, <code>LinkedList</code></li>
<li>Maps: <code>HashMap</code>, <code>BTreeMap</code></li>
<li>Sets: <code>HashSet</code>, <code>BTreeSet</code></li>
<li>Misc: <code>BinaryHeap</code></li>
</ul>
<p><code>Vec</code> and <code>HashMap</code> are the most commonly used.</p>
<p><code>Vec</code> (called <em>vector</em>) stores a variable number of values next to each other.</p>
<p><code>HashMap</code> associates values with a particular key.</p>
<p>In comparison, other types are consider <em>niche</em>.</p>
<h1><a class="header" href="#vectors" id="vectors">Vectors</a></h1>
<p><code>Vec&lt;T&gt;</code> is the most widely used collection.</p>
<p>It is used to store items of the same type <code>T</code>.</p>
<p>It is akin to a dynamically sized, heap-allocated, array.</p>
<h1><a class="header" href="#vector-basics" id="vector-basics">Vector Basics</a></h1>
<p><code>Vec</code> from <code>std::vec::Vec</code> is included in the prelude.</p>
<p>We can create a new <code>Vec</code> explicitly:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v: Vec&lt;i32&gt; = Vec::new();

println!(&quot;{:?}&quot;, v);
#}</code></pre></pre>
<p>Or we can create a new <code>Vec</code> with some initial content via a macro <code>vec!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

println!(&quot;{:?}&quot;, v);
#}</code></pre></pre>
<p>We can create the same <code>Vec</code> using the <code>push</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = Vec::new();

v.push(1);
v.push(2);
v.push(3);

println!(&quot;{:?}&quot;, v);
#}</code></pre></pre>
<p>When a vector goes out of scope, all its contents are dropped.</p>
<h1><a class="header" href="#reading-elements" id="reading-elements">Reading Elements</a></h1>
<p>There are two ways to reference a value stored in a vector: indexing syntax or
the <code>get</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;The third element is {}&quot;, third);

match v.get(2) {
    Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
    None =&gt; println!(&quot;There is no third element.&quot;),
}
#}</code></pre></pre>
<p>We can match on the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html?search=#method.get"><code>get</code>
method</a>
above because it returns <code>Option&lt;T&gt;</code>.</p>
<h1><a class="header" href="#reading-elements-1" id="reading-elements-1">Reading Elements</a></h1>
<p>Indexing into a non-existent element results in a panic:</p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
#}</code></pre></pre>
<p>Calling <code>get()</code> on a non-existent element returns <code>None</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = v.get(100);

# assert_eq!(None, does_not_exist);
#}</code></pre></pre>
<h1><a class="header" href="#reading-elements-2" id="reading-elements-2">Reading Elements</a></h1>
<p>What happens when we reference a vector element and then try to modify the
vector?</p>
<pre><code class="language-rust ignore does_not_compile">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;The first element is: {}&quot;, first);
</code></pre>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:11:1
   |
5  | let first = &amp;v[0];
   |              - immutable borrow occurs here
6  |
7  | v.push(6);
   | ^ mutable borrow occurs here
...
10 | }
   | - immutable borrow ends here
</code></pre>
<h1><a class="header" href="#iterating-over-values" id="iterating-over-values">Iterating over Values</a></h1>
<p>To iterate over immutable references:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let v: Vec&lt;u32&gt; = vec![100, 32, 57];
    for i in &amp;v {
        println!(&quot;{}&quot;, i);
        // Uncomment below to see the type of `i`!
        // assert_eq!((), i);
    }
}
</code></pre></pre>
<p>To iterate over mutable references:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}

println!(&quot;{:?}&quot;, v);
#}</code></pre></pre>
<p>Note: we need to <em>dereference</em> <code>i</code> using <code>*</code> before modifying.</p>
<h1><a class="header" href="#storing-multiple-types" id="storing-multiple-types">Storing Multiple Types</a></h1>
<p><code>Vec</code>s can only store items of the same time.</p>
<p>Rust must know the size of <code>T</code> at compile time such that it knows how much heap
memory to allocate for each elements.</p>
<p>An intermediate enum can be used to wrap an exhaustive set of types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];

println!(&quot;{:?}&quot;, row);
#}</code></pre></pre>
<p>If you don't know all the types the vector will hold at runtime, a <em>trait
object</em> can be used instead.</p>
<h1><a class="header" href="#hash-maps" id="hash-maps">Hash Maps</a></h1>
<p><a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">Hash maps</a> in
Rust are represented via the type <code>HashMap&lt;K, V&gt;</code>.</p>
<p>This is a mapping of keys of type <code>K</code> to values of type <code>V</code>.</p>
<p>Like vectors, types <code>K</code> and <code>V</code> are fixed at compile time.</p>
<h1><a class="header" href="#hash-map-basics" id="hash-map-basics">Hash Map Basics</a></h1>
<p>Like vectors, hash map data is stored on the heap.</p>
<p>Unlike vectors, <code>HashMap</code> is not included in the prelude and must be brought
into scope.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

println!(&quot;{:?}&quot;, scores);
#}</code></pre></pre>
<h1><a class="header" href="#hash-map-basics-1" id="hash-map-basics-1">Hash Map Basics</a></h1>
<p>Another way of creating <code>HashMap</code>s is by <code>collect</code>ing a vector of tuples.</p>
<p><code>zip</code>ing two vectors creates a single vector of tuples.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

fn main() {
    let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
    let initial_scores = vec![10, 50];

    let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();

    println!(&quot;{:?}&quot;, scores);
}
</code></pre></pre>
<p><code>HashMap&lt;_, _&gt;</code> is require with <code>collect</code> because we could collect other data
structures.</p>
<p>However, we can use <code>_</code> for <code>K</code> and <code>V</code> since these can be inferred.</p>
<h1><a class="header" href="#ownership-1" id="ownership-1">Ownership</a></h1>
<p>The <code>insert</code> method <em>moves</em> data into the hash map.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// `field_name` and `field_value` are now invalid!

println!(&quot;{:?}&quot;, map);
#}</code></pre></pre>
<p>The map above now owns <code>field_name</code> and <code>field_value</code>.</p>
<h1><a class="header" href="#accessing-values" id="accessing-values">Accessing Values</a></h1>
<p>We can directly attempt to <code>get</code> a value for a key:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);

assert_eq!(Some(&amp;10), score);
#}</code></pre></pre>
<h1><a class="header" href="#accessing-values-1" id="accessing-values-1">Accessing Values</a></h1>
<p>We can iterate over the keys/values of a hash map:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
#}</code></pre></pre>
<h1><a class="header" href="#updating-values" id="updating-values">Updating Values</a></h1>
<p>If we call <code>insert</code> on the same key twice, we can overwrite a value.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores)
#}</code></pre></pre>
<h1><a class="header" href="#updating-values-1" id="updating-values-1">Updating Values</a></h1>
<p>We can use the <code>entry</code> method to fetch an element that may or may not exist.</p>
<p>Coupled with <code>or_insert</code>, we can add a pair if the key does not already exist:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores)
#}</code></pre></pre>
<h1><a class="header" href="#updating-values-2" id="updating-values-2">Updating Values</a></h1>
<p>Finally, it's common to update a value based on the previous value:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map)
#}</code></pre></pre>
<h1><a class="header" href="#hashing-functions" id="hashing-functions">Hashing Functions</a></h1>
<p>By default, <code>HashMap</code> uses a cryptographically strong<sup class="footnote-reference"><a href="#siphash">1</a></sup> hashing
function that can provide resistance to Denial of Service (DoS) attacks.</p>
<p>In the interest of performance, an alternative <em>hasher</em> type can be created.</p>
<p>Alternatively, a drop-in replacement can be used like
<a href="https://github.com/Amanieu/hashbrown">https://github.com/Amanieu/hashbrown</a>
for instance.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.131002.net/siphash/siphash.pdf">https://www.131002.net/siphash/siphash.pdf</a></p>
</div>
<h1><a class="header" href="#emoji-fzf-part-4" id="emoji-fzf-part-4"><code>emoji-fzf</code>: Part 4</a></h1>
<img src="https://cdn.rawgit.com/noahp/emoji-fzf/assets/demo.svg">
<h1><a class="header" href="#last-time-4" id="last-time-4">Last Time</a></h1>
<p>We left off <a href="https://github.com/mvertescher/emoji-fzf/tree/2c7d356dc57e8b8bcd1e3b72692ce9ebf59fdca3">here</a>...</p>
<pre><code class="language-rust ignore"># extern crate clap;
use clap::{crate_name, crate_description, crate_version, crate_authors};
use clap::{App, Arg, SubCommand};

fn main() {
    let matches = App::new(crate_name!())
        .about(crate_description!())
        .version(crate_version!())
        .author(crate_authors!())
        .subcommand(SubCommand::with_name(&quot;get&quot;)
                    .about(&quot;Get unicode emoji given a name&quot;)
                    .arg(Arg::with_name(&quot;name&quot;)
                        .help(&quot;Name of the emoji to display&quot;)
                        .index(1)
                        .required(true)))
        .get_matches();

    match matches.subcommand() {
        (&quot;get&quot;, Some(m)) =&gt; {
            let name = m.value_of(&quot;name&quot;).unwrap();
            display_emoji(name);
        }
        _ =&gt; std::process::exit(0),
    }
}

fn display_emoji(name: &amp;str) {
    for emoji in emojis::EMOJIS {
        if name == emoji.0 {
            println!(&quot;{}&quot;, emoji.1);
            std::process::exit(0);
        }
    }
    std::process::exit(1);
}

mod emojis {
    pub const EMOJIS: &amp;[(&amp;str, &amp;str)] = &amp;[
        (&quot;grinning&quot;,&quot;&quot;),
        (&quot;grimacing&quot;,&quot;&quot;),
        // ...
        (&quot;united_nations&quot;,&quot;&quot;),
        (&quot;pirate_flag&quot;,&quot;&quot;),
    ];
}
</code></pre>
<h1><a class="header" href="#assignment-1" id="assignment-1">Assignment 1</a></h1>
<blockquote>
<p>Extend <code>clap::App</code> to print each emoji name on a new line when the <code>preview</code>
subcommand is called.</p>
</blockquote>
<pre><code class="language-rust ignore editable">extern crate clap;

use clap::{crate_name, crate_description, crate_version, crate_authors};
use clap::{App, Arg, SubCommand};

fn main() {
    let matches = App::new(crate_name!())
        .about(crate_description!())
        .version(crate_version!())
        .author(crate_authors!())
        .subcommand(SubCommand::with_name(&quot;get&quot;)
                    .about(&quot;Get unicode emoji given a name&quot;)
                    .arg(Arg::with_name(&quot;name&quot;)
                        .help(&quot;Name of the emoji to display&quot;)
                        .index(1)
                        .required(true)))
        .get_matches();

    match matches.subcommand() {
        (&quot;get&quot;, Some(m)) =&gt; {
            let name = m.value_of(&quot;name&quot;).unwrap();
            display_emoji(name);
        }
        _ =&gt; std::process::exit(0),
    }
}

fn display_emoji(name: &amp;str) {
    for emoji in emojis::EMOJIS {
        if name == emoji.0 {
            println!(&quot;{}&quot;, emoji.1);
            std::process::exit(0);
        }
    }
    std::process::exit(1);
}

mod emojis {
    pub const EMOJIS: &amp;[(&amp;str, &amp;str)] = &amp;[
        (&quot;grinning&quot;,&quot;&quot;),
        (&quot;grimacing&quot;,&quot;&quot;),
        // ...
        (&quot;united_nations&quot;,&quot;&quot;),
        (&quot;pirate_flag&quot;,&quot;&quot;),
    ];
}
</code></pre>
<h1><a class="header" href="#answer-1" id="answer-1">Answer 1</a></h1>
<blockquote>
<p>Extend <code>clap::App</code> to print each emoji name on a new line when the <code>preview</code>
subcommand is called.</p>
</blockquote>
<pre><code class="language-rust ignore">extern crate clap;

use clap::{crate_name, crate_description, crate_version, crate_authors};
use clap::{App, Arg, SubCommand};

fn main() {
    let matches = App::new(crate_name!())
        .about(crate_description!())
        .version(crate_version!())
        .author(crate_authors!())
        .subcommand(SubCommand::with_name(&quot;get&quot;)
                    .about(&quot;Get unicode emoji given a name&quot;)
                    .arg(Arg::with_name(&quot;name&quot;)
                        .help(&quot;Name of the emoji to display&quot;)
                        .index(1)
                        .required(true)))
        .subcommand(SubCommand::with_name(&quot;preview&quot;)
                    .about(&quot;Display a list of all available emojis by name&quot;))
        .get_matches();

    match matches.subcommand() {
        (&quot;get&quot;, Some(m)) =&gt; {
            let name = m.value_of(&quot;name&quot;).unwrap();
            display_emoji(name);
        }
        (&quot;preview&quot;, _) =&gt; {
            for emoji in emojis::EMOJIS {
                println!(&quot;{}&quot;, emoji.0);
            }
        }
        _ =&gt; std::process::exit(0),
    }
}

fn display_emoji(name: &amp;str) {
    for emoji in emojis::EMOJIS {
        if name == emoji.0 {
            println!(&quot;{}&quot;, emoji.1);
            std::process::exit(0);
        }
    }
    std::process::exit(1);
}

mod emojis {
    pub const EMOJIS: &amp;[(&amp;str, &amp;str)] = &amp;[
        (&quot;grinning&quot;,&quot;&quot;),
        (&quot;grimacing&quot;,&quot;&quot;),
        // ...
        (&quot;united_nations&quot;,&quot;&quot;),
        (&quot;pirate_flag&quot;,&quot;&quot;),
    ];
}
</code></pre>
<h1><a class="header" href="#assignment-2" id="assignment-2">Assignment 2</a></h1>
<blockquote>
<p>Refactor <code>emoji-fzf</code> by adding an <code>args</code> module that contains a function
<code>parse()</code>.</p>
<p><code>parse()</code> should return a <code>Command</code> enum with variants that contain any
argument data.</p>
<p><code>main()</code> should use the <code>Command</code> from <code>parse()</code> to call the appropriate
handler.</p>
</blockquote>
<pre><code class="language-rust ignore editable">extern crate clap;

use clap::{crate_name, crate_description, crate_version, crate_authors};
use clap::{App, Arg, SubCommand};

fn main() {
    let matches = App::new(crate_name!())
        .about(crate_description!())
        .version(crate_version!())
        .author(crate_authors!())
        .subcommand(SubCommand::with_name(&quot;get&quot;)
                    .about(&quot;Get unicode emoji given a name&quot;)
                    .arg(Arg::with_name(&quot;name&quot;)
                        .help(&quot;Name of the emoji to display&quot;)
                        .index(1)
                        .required(true)))
        .subcommand(SubCommand::with_name(&quot;preview&quot;)
                    .about(&quot;Display a list of all available emojis by name&quot;))
        .get_matches();

    match matches.subcommand() {
        (&quot;get&quot;, Some(m)) =&gt; {
            let name = m.value_of(&quot;name&quot;).unwrap();
            display_emoji(name);
        }
        (&quot;preview&quot;, _) =&gt; {
            for emoji in emojis::EMOJIS {
                println!(&quot;{}&quot;, emoji.0);
            }
        }
        _ =&gt; std::process::exit(0),
    }
}

fn display_emoji(name: &amp;str) {
    for emoji in emojis::EMOJIS {
        if name == emoji.0 {
            println!(&quot;{}&quot;, emoji.1);
            std::process::exit(0);
        }
    }
    std::process::exit(1);
}

mod emojis {
    pub const EMOJIS: &amp;[(&amp;str, &amp;str)] = &amp;[
        (&quot;grinning&quot;,&quot;&quot;),
        (&quot;grimacing&quot;,&quot;&quot;),
        // ...
        (&quot;united_nations&quot;,&quot;&quot;),
        (&quot;pirate_flag&quot;,&quot;&quot;),
    ];
}
</code></pre>
<h1><a class="header" href="#answer-2" id="answer-2">Answer 2</a></h1>
<blockquote>
<p>Refactor <code>emoji-fzf</code> by adding an <code>args</code> module that contains a function
<code>parse()</code>.</p>
<p><code>parse()</code> should return a <code>Command</code> enum with variants that contain any
argument data.</p>
<p><code>main()</code> should use the <code>Command</code> from <code>parse()</code> to call the appropriate
handler.</p>
</blockquote>
<pre><code class="language-rust ignore">extern crate clap;

enum Command {
    Get(String),
    Preview,
}

fn main() {
    let command = args::parse();

    match command {
        Command::Get(name) =&gt; display_emoji(&amp;name),
        Command::Preview =&gt; preview_emojis(),
    }
}

fn display_emoji(name: &amp;str) {
    for emoji in emojis::EMOJIS {
        if name == emoji.0 {
            println!(&quot;{}&quot;, emoji.1);
            std::process::exit(0);
        }
    }
    std::process::exit(1);
}

fn preview_emojis() {
    for emoji in emojis::EMOJIS {
        println!(&quot;{}&quot;, emoji.0);
    }
}

mod args {
    use super::Command;

    use clap::{crate_name, crate_description, crate_version, crate_authors};
    use clap::{App, Arg, SubCommand};

    pub(super) fn parse() -&gt; Command {
        let matches = App::new(crate_name!())
            .about(crate_description!())
            .version(crate_version!())
            .author(crate_authors!())
            .subcommand(SubCommand::with_name(&quot;get&quot;)
                        .about(&quot;Get unicode emoji given a name&quot;)
                        .arg(Arg::with_name(&quot;name&quot;)
                            .help(&quot;Name of the emoji to display&quot;)
                            .index(1)
                            .required(true)))
            .subcommand(SubCommand::with_name(&quot;preview&quot;)
                        .about(&quot;Display a list of all available emojis by name&quot;))
            .get_matches();

        match matches.subcommand() {
            (&quot;get&quot;, Some(m)) =&gt; {
                Command::Get(m.value_of(&quot;name&quot;).unwrap().to_string())
            }
            (&quot;preview&quot;, _) =&gt; {
                Command::Preview
            }
            _ =&gt; std::process::exit(0),
        }
    }
}

mod emojis {
    pub const EMOJIS: &amp;[(&amp;str, &amp;str)] = &amp;[
        (&quot;grinning&quot;,&quot;&quot;),
        (&quot;grimacing&quot;,&quot;&quot;),
        // ...
        (&quot;united_nations&quot;,&quot;&quot;),
        (&quot;pirate_flag&quot;,&quot;&quot;),
    ];
}
</code></pre>
<h1><a class="header" href="#today-4" id="today-4">Today</a></h1>
<p>Let's review the original alias for <code>emoji-fzf</code>:</p>
<pre><code class="language-bash">alias emoj=&quot;emoji-fzf preview | \
    fzf --preview 'emoji-fzf get --name {1}' | \
    cut -d \&quot; \&quot; -f 1 | \
    emoji-fzf get&quot;
</code></pre>
<p>The <code>name</code> subcommand is done!</p>
<p>We still need to implement the <code>preview</code> subcommand that is piped into <code>fzf</code>!</p>
<h1><a class="header" href="#the-preview-subcommand" id="the-preview-subcommand">The Preview Subcommand</a></h1>
<p>As a refresher, this is the expected behavior of <code>preview</code>:</p>
<pre><code class="language-sh">$ emoji-fzf preview
grinning face smile happy joy :D grin
grimacing face grimace teeth
...
united_nations un flag banner
pirate_flag skull crossbones flag banner
</code></pre>
<p>The name of the emoji is printed, followed by a list of associated keywords, on
the same line.</p>
<h1><a class="header" href="#introducing-serde-a-hrefhttpscratesiocratesserdeimg-srchttpsimgshieldsiocratesvserdesvg-altlatest-version-a" id="introducing-serde-a-hrefhttpscratesiocratesserdeimg-srchttpsimgshieldsiocratesvserdesvg-altlatest-version-a">Introducing <code>Serde</code> <a href="https://crates.io/crates/serde"><img src="https://img.shields.io/crates/v/serde.svg" alt="Latest Version" /></a></a></h1>
<p><a href="https://serde.rs/"><code>Serde</code></a> is a framework for <strong>ser</strong>ializing
and <strong>de</strong>serializing Rust data structures efficiently and
generically.</p>
<p><code>serde</code> supports a handful data formats out of the box including <a href="https://github.com/serde-rs/json">JSON</a>,
<a href="https://github.com/pyfisch/cbor">CBOR</a>, <a href="https://github.com/dtolnay/serde-yaml">YAML</a>, <a href="https://github.com/alexcrichton/toml-rs">TOML</a>, <a href="https://github.com/nox/serde_urlencoded">x-www-form-urlencoded</a> and many
more!</p>
<p>Out of the box, <code>serde</code> can deserialize many common Rust data structures and
primitive types like <code>String</code>, <code>{integer}</code>, <code>Vec&lt;T&gt;</code> and <code>HashMap&lt;K,V&gt;</code>.</p>
<p>A derive attribute is provided to generate implementations for simple data
structures.</p>
<h1><a class="header" href="#a-serde-example" id="a-serde-example">A Serde Example</a></h1>
<pre><code class="language-rust ignore"># extern crate serde;
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let point = Point { x: 1, y: 2 };

    // Convert the Point to a JSON string.
    let serialized = serde_json::to_string(&amp;point).unwrap();

    // Prints serialized = {&quot;x&quot;:1,&quot;y&quot;:2}
    println!(&quot;serialized = {}&quot;, serialized);

    // Convert the JSON string back to a Point.
    let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();

    // Prints deserialized = Point { x: 1, y: 2 }
    println!(&quot;deserialized = {:?}&quot;, deserialized);
}
</code></pre>
<h1><a class="header" href="#mapping-emojisjson" id="mapping-emojisjson">Mapping Emojis.json</a></h1>
<p>If you recall, <a href="https://github.com/muan/emojilib/blob/master/emojis.json">the original emoji file</a> we used looked something like this:</p>
<pre><code class="language-json">{
  &quot;grinning&quot;: {
    &quot;keywords&quot;: [&quot;face&quot;, &quot;smile&quot;, &quot;happy&quot;, &quot;joy&quot;, &quot;:D&quot;, &quot;grin&quot;],
    &quot;char&quot;: &quot;&quot;,
    &quot;fitzpatrick_scale&quot;: false,
    &quot;category&quot;: &quot;people&quot;
  },
  &quot;grimacing&quot;: {
    &quot;keywords&quot;: [&quot;face&quot;, &quot;grimace&quot;, &quot;teeth&quot;],
    &quot;char&quot;: &quot;&quot;,
    &quot;fitzpatrick_scale&quot;: false,
    &quot;category&quot;: &quot;people&quot;
  },

  ...
}
</code></pre>
<p>We had to use <code>jq</code> and <code>sed</code> to extract a Rust data structure from the format...</p>
<h1><a class="header" href="#mapping-emojisjson-1" id="mapping-emojisjson-1">Mapping Emojis.json</a></h1>
<p>With <code>serde</code>, we can map each JSON object to a Rust structure:</p>
<pre><code class="language-json">{
  &quot;grinning&quot;: {
    &quot;keywords&quot;: [&quot;face&quot;, &quot;smile&quot;, &quot;happy&quot;, &quot;joy&quot;, &quot;:D&quot;, &quot;grin&quot;],
    &quot;char&quot;: &quot;&quot;,
    &quot;fitzpatrick_scale&quot;: false,
    &quot;category&quot;: &quot;people&quot;
  }
}
</code></pre>
<p>Becomes...</p>
<pre><code class="language-rust ignore">#[derive(Deserialize, Debug)]
struct Emoji {
    keywords: Vec&lt;String&gt;,
    #[serde(rename = &quot;char&quot;)]
    ch: String,
    fitzpatrick_scale: bool,
    category: String,
}
</code></pre>
<h1><a class="header" href="#assignments-for-next-time" id="assignments-for-next-time">Assignments for Next Time!</a></h1>
<h3><a class="header" href="#1-read-a-hrefhttpsgithubcommuanemojilibblobmasteremojisjsonemojisjsona-from-a-file-into-a-string" id="1-read-a-hrefhttpsgithubcommuanemojilibblobmasteremojisjsonemojisjsona-from-a-file-into-a-string">1. Read <a href="https://github.com/muan/emojilib/blob/master/emojis.json"><code>emojis.json</code></a> from a file into a <code>String</code>.</a></h3>
<p><strong>Hint</strong>: There's a useful API called
<a href="https://doc.rust-lang.org/std/fs/fn.read_to_string.html"><code>std::fs::read_to_string</code></a></p>
<h3><a class="header" href="#2-use-serde-to-deserialize-the-a-hrefhttpsgithubcommuanemojilibblobmasteremojisjsonemojisjsona-file-into-a-hashmap-of-emoji" id="2-use-serde-to-deserialize-the-a-hrefhttpsgithubcommuanemojilibblobmasteremojisjsonemojisjsona-file-into-a-hashmap-of-emoji">2. Use <code>serde</code> to deserialize the <a href="https://github.com/muan/emojilib/blob/master/emojis.json"><code>emojis.json</code></a> file into a <code>HashMap</code> of <code>Emoji</code>.</a></h3>
<h3><a class="header" href="#3-replace-the-const-emoji-array-with-the-emoji-hashmap-for-the-get-subcommand" id="3-replace-the-const-emoji-array-with-the-emoji-hashmap-for-the-get-subcommand">3. Replace the const emoji array with the emoji <code>HashMap</code> for the <code>get</code> subcommand.</a></h3>
<h3><a class="header" href="#4-properly-implement-the-preview-command-using-the-emoji-hashmap" id="4-properly-implement-the-preview-command-using-the-emoji-hashmap">4. Properly implement the <code>preview</code> command using the emoji <code>HashMap</code>.</a></h3>
<h1><a class="header" href="#rust-workshop-part-vi" id="rust-workshop-part-vi">Rust Workshop: Part VI</a></h1>
<h2><a class="header" href="#error-handling" id="error-handling">Error Handling</a></h2>
<h1><a class="header" href="#last-time-5" id="last-time-5">Last Time</a></h1>
<ul>
<li>The Standard Library</li>
<li><code>Vec</code></li>
<li><code>String</code></li>
<li><code>HashMap</code></li>
<li><code>emoji-fzf</code>: Part 4</li>
</ul>
<h1><a class="header" href="#today-5" id="today-5">Today</a></h1>
<ul>
<li><code>panic!</code> and backtrace</li>
<li><code>Result&lt;T, E&gt;</code></li>
<li>When should you <code>panic!</code>?</li>
<li><code>emoji-fzf</code>: Part 5</li>
</ul>
<h1><a class="header" href="#quote-4" id="quote-4">Quote</a></h1>
<blockquote>
<p>Failure is not an OPTION&lt;T&gt;.</p>
<p>Its a Result&lt;T, E&gt;.</p>
<p> <a href="https://twitter.com/llogiq/status/956051804374134785">llogiq on Twitter</a></p>
</blockquote>
<h1><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h1>
<p>Rust groups errors into two major categories: <em>recoverable</em> and <em>unrecoverable</em>.</p>
<p>Sometime operations, like opening a file, can fail at runtime. This is an
example of an error that should be <em>recoverable</em>.</p>
<p>Errors that are <em>unrecoverable</em> are the symptom of software bugs.</p>
<p>In Rust:</p>
<ul>
<li><em>unrecoverable</em> errors: <code>panic!</code></li>
<li><em>recoverable</em> errors: <code>Result&lt;T, E&gt;</code></li>
</ul>
<h1><a class="header" href="#panic" id="panic"><code>panic!</code></a></h1>
<p>When a <code>panic!</code> occurs...</p>
<ul>
<li>A failure message will be printed</li>
<li>The stack is unwound and cleaned up</li>
<li>The program will quit</li>
</ul>
<p>When <em>optimizing for size</em>, we may just want to <em>abort</em> (end the program
without cleaning up). This feature can be enabled in a <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
<p>A panic reports the file and line number of the <code>panic!</code> call:</p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>A <code>panic!</code> can occur in a dependant crate...</p>
<h1><a class="header" href="#panic-backtrace" id="panic-backtrace"><code>panic!</code> Backtrace</a></h1>
<p>Take this example of a <a href="https://cwe.mitre.org/data/definitions/126.html"><em>buffer
over-read</em></a>:</p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p>In C, the compiler would <em>naively</em> allow you to fetch index 99 with no
questions. This would be a security vulnerability that could be exploited.</p>
<p>In Rust, this triggers a <code>panic!</code> in the Standard Library.</p>
<p>We can set the <code>RUST_BACKTRACE</code> environment variable to uncover the source of
the <code>panic!</code>.</p>
<h1><a class="header" href="#panic-backtrace-1" id="panic-backtrace-1"><code>panic!</code> Backtrace</a></h1>
<p>When working with <code>cargo</code>, it is common to run a command like below:</p>
<pre><code class="language-sh">$ RUST_BACKTRACE=1 cargo run
</code></pre>
<p>Let's print the backtrace:</p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
#     std::env::set_var(&quot;RUST_BACKTRACE&quot;, &quot;1&quot;);
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p>The informative output here is provided by debug symbols that are compiled into
binaries by default.</p>
<h1><a class="header" href="#result" id="result"><code>Result</code></a></h1>
<p>In C, there are a variety of different recoverable error handling techniques:</p>
<ul>
<li>None: Ignore errors with <code>void</code> returns</li>
<li>Binary: <code>bool</code> or <code>int</code> 0 on success failure otherwise</li>
<li>Status code: <code>int</code> 0 or a status code integer</li>
<li>Overloaded status code: 0 on success, status code if less than 0, meaningful
unsigned integer return if greater than zero</li>
<li>Robust: Error are pointers to structures (heap allocated) with associated
debugging data</li>
<li>Or even a combination of above!</li>
</ul>
<p>In Rust, there is a <a href="https://doc.rust-lang.org/core/result/"><code>core</code> (ubiquitous) type</a> for functions that can fail:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>We say: <code>Result&lt;T, E&gt;</code> is an enum with two variants <code>Ok</code> and <code>Err</code>. Both <code>T</code>
and <code>E</code> are <em>generic type parameters</em> (like <code>Option&lt;T&gt;</code>).</p>
<p><code>T</code> represents the type that will be returned in the success case and <code>E</code>
represents the error type that will returned in the failure case.</p>
<h1><a class="header" href="#using-result" id="using-result">Using <code>Result</code></a></h1>
<p>When you open a <code>File</code>, a <code>Result</code>  is returned:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;emojis.json&quot;);
}
</code></pre></pre>
<p>But, what are the types <code>T</code> and <code>E</code>?</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fs::File;

fn main() {
    // Uncomment below!
    // let f: () = File::open(&quot;emojis.json&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#matching-result" id="matching-result">Matching <code>Result</code></a></h1>
<p>To extract <code>T</code>, in this case <code>File</code>, from <code>Result</code>, we can use a match statement:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;emojis.json&quot;);

    let _f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p>On success, we return the concrete <code>File</code> type. Otherwise, we panic.</p>
<h1><a class="header" href="#matching-result-errors" id="matching-result-errors">Matching <code>Result</code> Errors</a></h1>
<p>What if we want to handle some errors differently?</p>
<p>Since the type of <code>E</code> is a struct <code>io::Error</code> that has a <code>kind</code> method that
returns an <code>io::ErrorKind</code> enum, we can add another <code>match</code> statement:</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;emojis.json&quot;);

    let _f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;emojis.json&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Tried to create file but there was a problem: {:?}&quot;, e),
            },
            other_error =&gt; panic!(&quot;There was a problem opening the file: {:?}&quot;, other_error),
        },
    };
}
</code></pre></pre>
<p>If the file is not found, we can handle the error and create it.</p>
<h1><a class="header" href="#matching-result-errors-1" id="matching-result-errors-1">Matching <code>Result</code> Errors</a></h1>
<p><code>match</code>ing is quite powerful, but also primitive. <code>Result</code> provides many
methods, like <a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a>, that accept closures instead:</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;emojis.json&quot;).map_err(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;emojis.json&quot;).unwrap_or_else(|error| {
                panic!(&quot;Tried to create file but there was a problem: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;There was a problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre></pre>
<p>The functionality above is identical to the double <code>match</code> we just saw.</p>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a> 'handles' the error, but leaves successful results
untouched.</p>
<p>This form is seen more often in the wild. We'll revisit this when we talk about
closures.</p>
<h1><a class="header" href="#shortcuts-for-panic-unwrap" id="shortcuts-for-panic-unwrap">Shortcuts for <code>panic!</code>: <code>unwrap</code></a></h1>
<p>Previously, we've used match to <code>panic!</code> on error:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;emojis.json&quot;);

    let _f = match f {
        Ok(file) =&gt; file,
        Err(_) =&gt; panic!(),
    };
}
</code></pre></pre>
<p>We seen this before! In more detail, <code>unwrap</code> is a method of <code>Result</code> (also
available with <code>Option</code>) that can help here:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let _f = File::open(&quot;emojis.json&quot;).unwrap();
}
</code></pre></pre>
<p><code>unwrap</code> is shorthand for &quot;give me <code>T</code> or <code>panic!</code>&quot;.</p>
<p>This is most useful in early prototyping situations.</p>
<h1><a class="header" href="#shortcuts-for-panic-expect" id="shortcuts-for-panic-expect">Shortcuts for <code>panic!</code>: <code>expect</code></a></h1>
<p>We've also seen <code>panic!</code> on error with a message:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;emojis.json&quot;);

    let _f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;There was a problem opening the file: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p>The <code>expect</code> method of <code>Result</code> (also available with <code>Option</code>) that can help here:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let _f = File::open(&quot;emojis.json&quot;).expect(&quot;Failed to open emojis.json&quot;);
}
</code></pre></pre>
<p><code>expect</code> is shorthand for &quot;give me <code>T</code> or <code>panic!</code> with a message&quot;.</p>
<p>This is useful in situations when we would like more information about where a
panic is in the code.</p>
<h1><a class="header" href="#propagating-errors" id="propagating-errors">Propagating Errors</a></h1>
<p>Often, we want to return errors from functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;emoji.json&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
#}</code></pre></pre>
<p>Above, we have to explicitly handle each error with a <code>match</code>.</p>
<p>Although this may feel similar to C, it's a practice that can become quite
verbose over time...</p>
<h1><a class="header" href="#propagating-errors-1" id="propagating-errors-1">Propagating Errors</a></h1>
<p>Over time, it was discovered that propagating errors up was <em>so common</em> that
Rust provides the <code>?</code> operator to make this easier.</p>
<p>Here's the last example simplified:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;emojis.json&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
#}</code></pre></pre>
<p><code>?</code> works almost identically to the <code>match</code> statements we had previously. It
produces <code>T</code> on success or early returns <code>E</code>.</p>
<p>The difference between the two is that <code>?</code> uses the <code>from</code> function, defined in
the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code> trait</a>, to convert errors when returning <code>E</code>.</p>
<h1><a class="header" href="#propagating-errors-2" id="propagating-errors-2">Propagating Errors</a></h1>
<p>In fact, we can chain <code>?</code> operators together:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;emojis.json&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
#}</code></pre></pre>
<p>Reading a file to a <code>String</code> is so common, there's a function for it
<code>fs::read_to_string</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::fs;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;emojis.json&quot;)
}
#}</code></pre></pre>
<h1><a class="header" href="#the--operator" id="the--operator">The <code>?</code> Operator</a></h1>
<p>There are a few more things to note about <code>?</code>:</p>
<p><code>?</code> can be used with types other than <code>Result</code> if they implement the trait
<a href="https://doc.rust-lang.org/std/ops/trait.Try.html">std::ops::Try</a>, like <code>Option</code>.</p>
<p>Can we use the <code>?</code> in our main function?</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fs::File;

fn main() {
    // Uncomment below!
    // let _f = File::open(&quot;emojis.json&quot;)?;
}
</code></pre></pre>
<h1><a class="header" href="#the--operator-1" id="the--operator-1">The <code>?</code> Operator</a></h1>
<p>We can specify a <code>Result</code> return in our main function to use the <code>?</code> operator:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let _f = File::open(&quot;emojis.json&quot;)?;

    Ok(())
}
</code></pre></pre>
<p><code>Box&lt;dyn Error&gt;</code> is something called a <em>trait object</em>. For now, this means any
kind of error. More on this later!</p>
<h1><a class="header" href="#to-panic-or-not-to-panic" id="to-panic-or-not-to-panic">To <code>panic!</code> or Not to <code>panic!</code></a></h1>
<p>Sometimes, it is ok to <code>panic!</code>:</p>
<ul>
<li>Examples, prototypes, tests</li>
<li>When you have more information than the compiler:
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
#}</code></pre></pre>
</li>
<li>Your binary will end up in an unrecoverable bad state</li>
<li>Your library is being misused and the calling programmers need to fix their code</li>
</ul>
<p>In all other cases, it is preferable to return a <code>Result</code>.</p>
<h1><a class="header" href="#emoji-fzf-part-5" id="emoji-fzf-part-5"><code>emoji-fzf</code>: Part 5</a></h1>
<img src="https://cdn.rawgit.com/noahp/emoji-fzf/assets/demo.svg">
<h1><a class="header" href="#last-time-6" id="last-time-6">Last Time</a></h1>
<p>We left off <a href="https://github.com/mvertescher/emoji-fzf/tree/7b63ebd3f26fc2859da86d53b99c04c99da39d25">here</a>...</p>
<pre><code class="language-rust ignore">extern crate clap;

enum Command {
    Get(String),
    Preview,
}

fn main() {
    let command = args::parse();

    match command {
        Command::Get(name) =&gt; display_emoji(&amp;name),
        Command::Preview =&gt; preview_emojis(),
    }
}

fn display_emoji(name: &amp;str) {
    for emoji in emojis::EMOJIS {
        if name == emoji.0 {
            println!(&quot;{}&quot;, emoji.1);
            std::process::exit(0);
        }
    }
    std::process::exit(1);
}

fn preview_emojis() {
    for emoji in emojis::EMOJIS {
        println!(&quot;{}&quot;, emoji.0);
    }
}

mod args {
    use super::Command;

    use clap::{crate_name, crate_description, crate_version, crate_authors};
    use clap::{App, Arg, SubCommand};

    pub(super) fn parse() -&gt; Command {
        let matches = App::new(crate_name!())
            .about(crate_description!())
            .version(crate_version!())
            .author(crate_authors!())
            .subcommand(SubCommand::with_name(&quot;get&quot;)
                        .about(&quot;Get unicode emoji given a name&quot;)
                        .arg(Arg::with_name(&quot;name&quot;)
                            .help(&quot;Name of the emoji to display&quot;)
                            .index(1)
                            .required(true)))
            .subcommand(SubCommand::with_name(&quot;preview&quot;)
                        .about(&quot;Display a list of all available emojis by name&quot;))
            .get_matches();

        match matches.subcommand() {
            (&quot;get&quot;, Some(m)) =&gt; {
                Command::Get(m.value_of(&quot;name&quot;).unwrap().to_string())
            }
            (&quot;preview&quot;, _) =&gt; {
                Command::Preview
            }
            _ =&gt; std::process::exit(0),
        }
    }
}

mod emojis {
    pub const EMOJIS: &amp;[(&amp;str, &amp;str)] = &amp;[
        (&quot;grinning&quot;,&quot;&quot;),
        (&quot;grimacing&quot;,&quot;&quot;),
        // ...
        (&quot;united_nations&quot;,&quot;&quot;),
        (&quot;pirate_flag&quot;,&quot;&quot;),
    ];
}
</code></pre>
<h1><a class="header" href="#assignment-1-1" id="assignment-1-1">Assignment 1</a></h1>
<blockquote>
<p>Read <a href="https://github.com/muan/emojilib/blob/master/emojis.json"><code>emojis.json</code></a> from a file into a <code>String</code>.</p>
<p><strong>Hint</strong>: There's a useful API called <a href="errors/emoji_fzf_part_5/(https://doc.rust-lang.org/std/fs/fn.read_to_string.html)"><code>std::fs::read_to_string</code></a></p>
</blockquote>
<h1><a class="header" href="#answer-1-1" id="answer-1-1">Answer 1</a></h1>
<blockquote>
<p>Read <a href="https://github.com/muan/emojilib/blob/master/emojis.json"><code>emojis.json</code></a> from a file into a <code>String</code>.</p>
<p><strong>Hint</strong>: There's a useful API called <a href="errors/emoji_fzf_part_5/(https://doc.rust-lang.org/std/fs/fn.read_to_string.html)"><code>std::fs::read_to_string</code></a></p>
</blockquote>
<h1><a class="header" href="#assignment-2-1" id="assignment-2-1">Assignment 2</a></h1>
<blockquote>
<p>Use <code>serde</code> to deserialize the <a href="https://github.com/muan/emojilib/blob/master/emojis.json"><code>emojis.json</code></a> file into a
<code>HashMap</code> of <code>Emoji</code>.</p>
</blockquote>
<h1><a class="header" href="#answer-2-1" id="answer-2-1">Answer 2</a></h1>
<blockquote>
<p>Use <code>serde</code> to deserialize the <a href="https://github.com/muan/emojilib/blob/master/emojis.json"><code>emojis.json</code></a> file into a
<code>HashMap</code> of <code>Emoji</code>.</p>
</blockquote>
<h1><a class="header" href="#assignment-3" id="assignment-3">Assignment 3</a></h1>
<blockquote>
<p>Replace the const emoji array with the emoji <code>HashMap</code> for the <code>get</code>
subcommand.</p>
</blockquote>
<h1><a class="header" href="#answer-3" id="answer-3">Answer 3</a></h1>
<blockquote>
<p>Replace the const emoji array with the emoji <code>HashMap</code> for the <code>get</code>
subcommand.</p>
</blockquote>
<h1><a class="header" href="#assignment-4" id="assignment-4">Assignment 4</a></h1>
<blockquote>
<p>Properly implement the <code>preview</code> command using the emoji <code>HashMap</code>.</p>
</blockquote>
<h1><a class="header" href="#answer-4" id="answer-4">Answer 4</a></h1>
<blockquote>
<p>Properly implement the <code>preview</code> command using the emoji <code>HashMap</code>.</p>
</blockquote>
<h1><a class="header" href="#assignments-for-next-time-1" id="assignments-for-next-time-1">Assignments for Next Time!</a></h1>
<h3><a class="header" href="#1-use-result-boxdyn-error-to-provide-graceful-exits-in-emoji-fzf" id="1-use-result-boxdyn-error-to-provide-graceful-exits-in-emoji-fzf">1. Use <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code> to provide graceful exits in <code>emoji-fzf</code></a></h3>
<h1><a class="header" href="#rust-workshop-part-vii" id="rust-workshop-part-vii">Rust Workshop: Part VII</a></h1>
<h2><a class="header" href="#generics" id="generics">Generics</a></h2>
<h1><a class="header" href="#last-time-7" id="last-time-7">Last Time</a></h1>
<ul>
<li><code>panic!</code> and backtrace</li>
<li><code>Result&lt;T, E&gt;</code></li>
<li>When should you <code>panic!</code>?</li>
<li><code>emoji-fzf</code>: Part 5</li>
</ul>
<h1><a class="header" href="#today-6" id="today-6">Today</a></h1>
<ul>
<li>Introduction</li>
<li>What are generic data types?</li>
<li>Syntax
<ul>
<li>Functions</li>
<li>Structs</li>
<li>Enums</li>
<li>Methods</li>
</ul>
</li>
<li>Performance of generics</li>
<li>Workshop</li>
</ul>
<h1><a class="header" href="#quote-5" id="quote-5">Quote</a></h1>
<blockquote>
<p>once you can walk barefoot (C), its easy to learn to walk with shoes (go)
but it will take time to learn to ride a bike (rust)</p>
</blockquote>
<p> <a href="https://www.reddit.com/r/rust/comments/6srf8h/thoughts_from_a_dumb_person_notes_on_my_threeweek/dlf58jt/">/u/freakhill on Reddit</a></p>
<h1><a class="header" href="#introduction-2" id="introduction-2">Introduction</a></h1>
<p><em>Generics</em> are abstract stand-ins for concrete types or other properties.</p>
<p>They help us effectively handle the duplication of concepts.</p>
<p>There are three generics related concepts in Rust that are important:</p>
<ul>
<li><em>Generic data types</em>: An abstract type that expresses ranges for concrete
types.</li>
<li><em>Traits</em>: Used to define behavior in a generic way.</li>
<li><em>Lifetimes</em>: A variety of generics that gives the compiler information about
how references relate to one another.</li>
</ul>
<p>Today, we're just going to focus on the syntax and use of <em>generic data types</em>.</p>
<h1><a class="header" href="#removing-duplication" id="removing-duplication">Removing Duplication</a></h1>
<p>Consider this example that finds the largest number in a <code>Vec</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p>There's some duplication here, we can simplify this code...</p>
<h1><a class="header" href="#removing-duplication-1" id="removing-duplication-1">Removing Duplication</a></h1>
<p>We can extract out a function for finding the largest value in a list:</p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
}
</code></pre></pre>
<p>Much better!</p>
<h1><a class="header" href="#removing-duplication-2" id="removing-duplication-2">Removing Duplication</a></h1>
<p>But, what happens when we want to find the largest value in lists of two
<em>different</em> types.</p>
<p>We need two different functions:</p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p>Not great! It <em>feels</em> like were duplicating code again!</p>
<h1><a class="header" href="#removing-duplication-3" id="removing-duplication-3">Removing Duplication</a></h1>
<p>We can further reduce duplication by creating a <em>generic type parameter</em> for
the type of the array.</p>
<p>The type parameter <code>T</code> must be declared before use: <code>fn largest&lt;T&gt;</code>.</p>
<p>Now we can define a single <code>largest</code> function:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p>Unfortunately, this does not compile...</p>
<pre><code class="language-plaintext">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`
</code></pre>
<p>The compiler is telling us that <code>&gt;</code> may <em>not</em> work for all types <code>T</code>.</p>
<p>We need to introduce <em>traits</em> to solve this problem. Stay tuned!</p>
<h1><a class="header" href="#generic-structs" id="generic-structs">Generic Structs</a></h1>
<p>When declaring structs with generic parameters, we must declare them after the
struct name inside angled brackets:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><code>Point&lt;T&gt;</code> holds <code>x</code> and <code>y</code> values both of type <code>T</code>.</p>
<h1><a class="header" href="#generic-structs-1" id="generic-structs-1">Generic Structs</a></h1>
<p>What happens if we create a point with <code>x</code> and <code>y</code> as different types?</p>
<pre><code class="language-rust ignore">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<pre><code class="language-plaintext">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<p>Remember that a <code>T</code> must be a single known type at compile time.</p>
<h1><a class="header" href="#generic-structs-2" id="generic-structs-2">Generic Structs</a></h1>
<p>Luckily, we can fix this by adding another type parameter:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><code>x</code> and <code>y</code> can now be the same or different types.</p>
<h1><a class="header" href="#generic-enums" id="generic-enums">Generic Enums</a></h1>
<p>We've seen two generic enums already:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>For both these cases, <code>T</code> and <code>E</code> can be <em>any</em> type.</p>
<p>Note that many different <code>Option</code>s or <code>Result</code>s can exist. Generics help remove
duplication.</p>
<h1><a class="header" href="#generic-methods" id="generic-methods">Generic Methods</a></h1>
<p>We can implement methods on structs and enums using generic types:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p>Note that we have to declare <code>T</code> right after <code>impl</code> so we can use it to specify
that we're implementing methods on the type <code>Point&lt;T&gt;</code>.</p>
<p>By declaring <code>T</code> as generic type after <code>impl</code>, the compiler can identify that
the type in the angle brackets in <code>Point</code> is a generic type rather than a
concrete type.</p>
<h1><a class="header" href="#generic-methods-1" id="generic-methods-1">Generic Methods</a></h1>
<p>We could implement methods only on <code>Point&lt;f32&gt;</code> instances rather than on
<code>Point&lt;T&gt;</code> instances with any generic type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#generic-methods-2" id="generic-methods-2">Generic Methods</a></h1>
<p>Generic type parameters in struct definitions are <em>not</em> always the same as
those used in method signatures.</p>
<p>Below, <code>Point&lt;T, U&gt;</code> has a method <code>mixup</code> that declares two new generic type
parameters <code>V</code> and <code>W</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<h1><a class="header" href="#performance" id="performance">Performance</a></h1>
<p>In Rust, the implementation of generics is optimised for performance.</p>
<p>There is no dynamic runtime cost. Code using generics is no slower that it
would be using concrete types.</p>
<p>Rust accomplishes this by performing <em>monomorphization</em> of code that is using
generics at compile time.</p>
<blockquote>
<p><em>Monomorphization</em> is the process of turning generic code into specific code
by filling in the concrete that are used when compiled.</p>
</blockquote>
<p>In other words,</p>
<blockquote>
<p><em>Monomorphization</em> is the conversion from polymorphic to monomorphic code.</p>
</blockquote>
<p>This process is similar to the way C++ templates compile.</p>
<h1><a class="header" href="#performance-1" id="performance-1">Performance</a></h1>
<p>Let's look at an example of two different concrete types:
<code>Option&lt;i32&gt;</code> and <code>Option&lt;f64&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let integer = Some(5);
let float = Some(5.0);
#}</code></pre></pre>
<p>The Rust compiler performs <em>monomorphization</em> on the code above to something
like below.</p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>There is no runtime cost! This code is compiled <em>exactly</em> as if we created two
separate definitions.</p>
<h1><a class="header" href="#workshop" id="workshop">Workshop</a></h1>
<p>We going to dive a little deeper into generics!</p>
<h1><a class="header" href="#question-1" id="question-1">Question 1</a></h1>
<p>Does this compile?</p>
<pre><code class="language-rust ignore">struct Foo;
struct Bar&lt;T&gt;(T);

impl Bar&lt;Foo&gt; {
    fn name_foo(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

impl Bar&lt;T&gt; {
    fn name_t(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}
</code></pre>
<h1><a class="header" href="#answer-1-2" id="answer-1-2">Answer 1</a></h1>
<p>No! We missed the type parameter declaration <code>&lt;T&gt;</code> after <code>impl</code> when declaring
the <code>impl</code> block for <code>Bar&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Foo;
struct Bar&lt;T&gt;(T);

impl Bar&lt;Foo&gt; {
    fn name_foo(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

// BAD: impl Bar&lt;T&gt; {
impl&lt;T&gt; Bar&lt;T&gt; {
    fn name_t(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}

fn main() {}
</code></pre></pre>
<p>The complier expected <code>T</code> to be a concrete type instead of a generic type
parameter!</p>
<h1><a class="header" href="#question-2" id="question-2">Question 2</a></h1>
<p>Does this compile? If so, what is printed?</p>
<pre><code class="language-rust ignore">struct Foo;
struct Bar&lt;T&gt;(T);

impl Bar&lt;Foo&gt; {
    fn name_foo(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

impl&lt;T&gt; Bar&lt;T&gt; {
    fn name_t(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}

fn main() {
    let x = Bar(Foo);
    let y = Bar(10);
    let z = Bar(&quot;foo&quot;);

    x.name_foo();
    y.name_t();
    z.name_t();
}
</code></pre>
<h1><a class="header" href="#answer-2-2" id="answer-2-2">Answer 2</a></h1>
<p>Yes!</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo;
struct Bar&lt;T&gt;(T);

impl Bar&lt;Foo&gt; {
    fn name_foo(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

impl&lt;T&gt; Bar&lt;T&gt; {
    fn name_t(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}

fn main() {
    let x = Bar(Foo);
    let y = Bar(10);
    let z = Bar(&quot;foo&quot;);

    x.name_foo();
    y.name_t();
    z.name_t();
}
</code></pre></pre>
<h1><a class="header" href="#question-3" id="question-3">Question 3</a></h1>
<p>Does this compile? If so, what is printed?</p>
<pre><code class="language-rust ignore">struct Foo;
struct Bar&lt;T&gt;(T);

impl Bar&lt;Foo&gt; {
    fn name(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

impl&lt;T&gt; Bar&lt;T&gt; {
    fn name(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}

fn main() {
    let x = Bar(Foo);
    let y = Bar(10);
    let z = Bar(&quot;foo&quot;);

    x.name();
    y.name();
    z.name();
}
</code></pre>
<h1><a class="header" href="#answer-3-1" id="answer-3-1">Answer 3</a></h1>
<p>No! But, why?</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Foo;
struct Bar&lt;T&gt;(T);

/*
impl Bar&lt;Foo&gt; {
    fn name(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

impl&lt;T&gt; Bar&lt;T&gt; {
    fn name(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}
*/

fn main() {
    let x = Bar(Foo);
    let y = Bar(10);
    let z = Bar(&quot;foo&quot;);
/*
    x.name();
    y.name();
    z.name();
*/
}
</code></pre></pre>
<h1><a class="header" href="#question-4" id="question-4">Question 4</a></h1>
<p>How is the code <em>monomorphized</em> at compile time?</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo;
struct Bar&lt;T&gt;(T);

impl Bar&lt;Foo&gt; {
    fn name_foo(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

impl&lt;T&gt; Bar&lt;T&gt; {
    fn name_t(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}

fn main() {
    let x = Bar(Foo);
    let y = Bar(10);
    let z = Bar(&quot;foo&quot;);

    x.name_foo();
    y.name_t();
    z.name_t();
}
</code></pre></pre>
<h1><a class="header" href="#answer-4-1" id="answer-4-1">Answer 4</a></h1>
<p>Let's enumerate all the concrete types created:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Bar_Foo;
struct Bar_i32;
struct Bar_str;

impl Bar_Foo {
    fn name_foo(&amp;self) {
        println!(&quot;Bar&lt;Foo&gt;&quot;);
    }
}

impl Bar_i32 {
    fn name_t(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}

impl Bar_str {
    fn name_t(&amp;self) {
        println!(&quot;Bar&lt;T&gt;&quot;);
    }
}

fn main() {
    let x = Bar_Foo;
    let y = Bar_i32;
    let z = Bar_str;

    x.name_foo();
    y.name_t();
    z.name_t();
}
</code></pre></pre>
<p>Do you notice anything here? Specifically, are there any tradeoffs associated
with <em>monomorphization</em>?</p>
<h1><a class="header" href="#rust-workshop-part-viii" id="rust-workshop-part-viii">Rust Workshop: Part VIII</a></h1>
<h2><a class="header" href="#traits" id="traits">Traits</a></h2>
<h1><a class="header" href="#last-time-8" id="last-time-8">Last Time</a></h1>
<ul>
<li>Introduction</li>
<li>What are generic data types?</li>
<li>Syntax
<ul>
<li>Functions</li>
<li>Structs</li>
<li>Enums</li>
<li>Methods</li>
</ul>
</li>
<li>Performance of generics</li>
<li>Workshop</li>
</ul>
<h1><a class="header" href="#today-7" id="today-7">Today</a></h1>
<ul>
<li>Traits
<ul>
<li>Defining traits</li>
<li>Implementing traits</li>
<li>Default implementations</li>
</ul>
</li>
<li>Trait bounds
<ul>
<li>Traits as parameters</li>
<li>Returning types that implement traits</li>
<li>Conditionally implementing methods</li>
</ul>
</li>
<li>Workshop</li>
</ul>
<h1><a class="header" href="#quote-6" id="quote-6">Quote</a></h1>
<blockquote>
<p>Using (traits) for Inheritance was like putting car wheels on a boat because
I am used to driving a vehicle with wheels.</p>
</blockquote>
<p> Marco Alka on <a href="https://hashnode.com/post/how-to-become-a-rust-super-developer-cjpv1ee7e000buhs2aqrdw2ym">Hashnode</a></p>
<h1><a class="header" href="#introduction-3" id="introduction-3">Introduction</a></h1>
<p><em>Traits</em> define shared behavior.</p>
<p><em>Trait bounds</em> can be used to specify the behavior of generic type parameter.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called <em>interfaces</em> in other
languages, although with some differences.</p>
</blockquote>
<p>Traits in Rust are most similar <em>type classes</em> in Haskell:</p>
<ul>
<li>It is possible to add traits to arbitrary data types, including primitive
types.</li>
<li>Traits can define a default implementation for a method.</li>
<li>A trait can be used for operator overloading. For example, we can 'redefine'
<code>==</code>.</li>
<li>Each overloadable operator in Rust has a corresponding trait in the standard
library.</li>
</ul>
<h1><a class="header" href="#defining-a-trait" id="defining-a-trait">Defining a Trait</a></h1>
<p>Trait definitions are a way to group method signatures together to define a set
of behaviors to accomplish some purpose.</p>
<p>Let's define a trait with a single method.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p>We have not defined an implementation for the <code>summarize</code> method.</p>
<p>The complier will be responsible for enforcing that types provide an
implementation for <code>summarize</code> if the type has the <code>Summary</code> trait.</p>
<p>A trait can have multiple methods in its body.</p>
<h1><a class="header" href="#implementing-traits" id="implementing-traits">Implementing Traits</a></h1>
<p>Let's implement <code>Summary</code> on some types:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
#}</code></pre></pre>
<p>Implementing a trait on a type is similar to implementing methods on a type.</p>
<p>Instead of <code>impl Type</code>, we have <code>impl Trait for Type</code>.</p>
<h1><a class="header" href="#implementing-traits-1" id="implementing-traits-1">Implementing Traits</a></h1>
<p>Let's now use the <code>summary</code> method from the <code>Summary</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}

let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize())
#}</code></pre></pre>
<p>We've defined our trait and type locally here so we don't need to bring
anything into scope.</p>
<p>What happens when our trait or type is not local to our crate?</p>
<h1><a class="header" href="#implementing-traits-2" id="implementing-traits-2">Implementing Traits</a></h1>
<p>If we wanted to implement an external trait on our local type, we would need to
bring the trait into scope first.</p>
<p>Alternatively, we could implement a local trait on an external type.</p>
<p>But, we <em>cannot</em> implement external traits on external types.</p>
<p>This restriction is part of a property of programs called <em>coherence</em>,
specifically, the <em>orphan rule</em>, that ensures you cannot break other peoples
code and vice-versa.</p>
<p>Without this rule, two crates could implement the same trait for the same type,
and Rust would not know which implementation to use.</p>
<h1><a class="header" href="#default-implementations" id="default-implementations">Default Implementations</a></h1>
<p>It's useful for reuse to provide default behaviors for some methods of a trait
instead of forcing types to reimplement them.</p>
<p>We can always keep or override each method's default behavior.</p>
<p>Let's give the <code>summarize</code> method a default implementation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}

pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {};

let article = NewsArticle {
    headline: String::from(&quot;Bruins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Boston, MA, USA&quot;),
    author: String::from(&quot;GFY&quot;),
    content: String::from(&quot;The Boston Bruins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summarize())
#}</code></pre></pre>
<p>We can omit an implementation for <code>summary</code> in <code>impl Summary for NewsArticle {};</code> and are still able to call the default <code>summary</code> function.</p>
<h1><a class="header" href="#default-implementations-1" id="default-implementations-1">Default Implementations</a></h1>
<p>Default implementations can call other methods in the same trait, even if those
methods do not have a default implementation.</p>
<p>A trait can provide a large amount of functionality even if types that
implement the trait only implement a fraction of the methods.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}

let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
#}</code></pre></pre>
<p>Here, we get the behavior of the <code>summarize</code> method for free because we
implemented <code>summarize_author</code>.</p>
<h1><a class="header" href="#traits-as-parameters" id="traits-as-parameters">Traits as Parameters</a></h1>
<p>Now that we know how to define traits and implement them on types, we can use
traits as parameters.</p>
<p>Let's look a short example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct Text {
    pub content: String,
}

impl Summary for Text {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}&quot;, self.content)
    }
}

pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}

let text = Text { content: String::from(&quot;This is a text...&quot;) };
notify(text);
#}</code></pre></pre>
<p>We can call the <code>notify</code> function with any type that implements <code>Summary</code>.</p>
<h1><a class="header" href="#trait-bound-syntax" id="trait-bound-syntax">Trait Bound Syntax</a></h1>
<p><code>impl Trait</code> is syntactic sugar for a longer syntax called a <em>trait bound</em>.</p>
<pre><pre class="playpen"><code class="language-rust editable">pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct Text {
    pub content: String,
}

impl Summary for Text {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}&quot;, self.content)
    }
}

fn main() {
    // pub fn notify(item: impl Summary) {
    pub fn notify&lt;T: Summary&gt;(item: T) {
        println!(&quot;Breaking news! {}&quot;, item.summarize());
    }

    // The following two lines express the same signature
    // pub fn notify_all(item1: impl Summary, item2: impl Summary) {
    pub fn notify_all&lt;T: Summary&gt;(item1: T, item2: T) {
        println!(&quot;Breaking news! {} {}&quot;, item1.summarize(), item2.summarize());
    }

    let text = Text { content: String::from(&quot;This is a text...&quot;) };

    notify(text);
    // notify_all(text, text);
}
</code></pre></pre>
<p>The <code>&lt;T: Trait&gt;</code> syntax specifies a trait bound, <code>Trait</code>, on <code>T</code>.</p>
<h1><a class="header" href="#trait-bounds-syntax" id="trait-bounds-syntax">Trait Bounds Syntax</a></h1>
<p>If we need to impose multiple trait bounds on a type we use the <code>+</code> operator:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

pub struct Text {
    pub content: String,
}

impl Summary for Text {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}&quot;, self.content)
    }
}

impl fmt::Display for Text {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.content)
    }
}

pub fn notify&lt;T: Summary + fmt::Display&gt;(item: T) {
    println!(&quot;Breaking news! {} {}&quot;, item, item.summarize());
}

let text = Text { content: String::from(&quot;This is a text...&quot;) };
notify(text);
#}</code></pre></pre>
<h1><a class="header" href="#where-clauses" id="where-clauses">Where Clauses</a></h1>
<p>When we have many trait bounds and many types, things can become unwieldy:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>We can use a <code>where</code> clause for complex situations:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>The function signature is <em>less</em> cluttered and more clear!</p>
<h1><a class="header" href="#returning-types-that-implement-traits" id="returning-types-that-implement-traits">Returning Types that Implement Traits</a></h1>
<p>We can use the <code>impl Trait</code> syntax in the return position as well:</p>
<pre><code class="language-rust ignore">fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p><code>returns_summarizable</code> returns a type that implements <code>Summary</code>, but does not
specify the concrete type.</p>
<p>This syntax is especially useful in the context of iterators an closures since
the <code>impl Trait</code> return syntax lets us specify functions that return a type
that implements the <code>Iterator</code> trait without needing to write out a long type.</p>
<h1><a class="header" href="#returning-types-that-implement-traits-1" id="returning-types-that-implement-traits-1">Returning Types that Implement Traits</a></h1>
<p>There's a catch! We can only use <code>impl Trait</code> if we're returning a single type.</p>
<pre><code class="language-rust ignore"># pub trait Summary {
#     fn summarize(&amp;self) -&gt; String;
# }
#
# pub struct NewsArticle {
#     pub headline: String,
#     pub location: String,
#     pub author: String,
#     pub content: String,
# }
#
# impl Summary for NewsArticle {
#     fn summarize(&amp;self) -&gt; String {
#         format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
#     }
# }
#
# pub struct Tweet {
#     pub username: String,
#     pub content: String,
#     pub reply: bool,
#     pub retweet: bool,
# }
#
# impl Summary for Tweet {
#     fn summarize(&amp;self) -&gt; String {
#         format!(&quot;{}: {}&quot;, self.username, self.content)
#     }
# }
fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(&quot;The Pittsburgh Penguins once again are the best
            hockey team in the NHL.&quot;),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(&quot;of course, as you probably already know, people&quot;),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<pre><code class="language-plaintext">error[E0308]: if and else have incompatible types
  --&gt; src/main.rs:43:9
   |
34 |   /     if switch {
35 |   |         NewsArticle {
   |  _|_________-
36 | | |             headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
37 | | |             location: String::from(&quot;Pittsburgh, PA, USA&quot;),
38 | | |             author: String::from(&quot;Iceburgh&quot;),
39 | | |             content: String::from(&quot;The Pittsburgh Penguins once again are the best
40 | | |             hockey team in the NHL.&quot;),
41 | | |         }
   | |_|_________- expected because of this
42 |   |     } else {
43 | / |         Tweet {
44 | | |             username: String::from(&quot;horse_ebooks&quot;),
45 | | |             content: String::from(&quot;of course, as you probably already know, people&quot;),
46 | | |             reply: false,
47 | | |             retweet: false,
48 | | |         }
   | |_|_________^ expected struct `main::NewsArticle`, found struct `main::Tweet`
49 |   |     }
   |   |_____- if and else have incompatible types
   |
   = note: expected type `main::NewsArticle`
              found type `main::Tweet`
</code></pre>
<p>This is a restriction on the way <code>impl Trait</code> is implemented.</p>
<p>We need to discuss Trait Objects to write a function in this way.</p>
<h1><a class="header" href="#fixing-the-largest-function" id="fixing-the-largest-function">Fixing the Largest Function</a></h1>
<p>Remember our <code>longest</code> function from last time had a compiler error:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<pre><code class="language-plaintext">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`
</code></pre>
<p>We're missing a bound on <code>T</code>!</p>
<h1><a class="header" href="#fixing-the-largest-function-1" id="fixing-the-largest-function-1">Fixing the Largest Function</a></h1>
<p>Let's add a trait bound on <code>T</code> for <code>std::cmp::PartialOrd</code>:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p>Unfortunately, this does not compile!</p>
<pre><code class="language-plaintext">error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content

error: aborting due to 2 previous errors
</code></pre>
<p>Not all types, <code>T</code>, can be moved (stack-only data copy). We need be more specific
about the types here.</p>
<h1><a class="header" href="#fixing-the-largest-function-2" id="fixing-the-largest-function-2">Fixing the Largest Function</a></h1>
<p>We can only call the longest function with types that support <code>Copy</code> like <code>i32</code>
and <code>char</code>.</p>
<p>Let's add <code>Copy</code> as a trait bound:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);


/*
    let string_list = vec![
        String::from(&quot;one&quot;),
        String::from(&quot;two&quot;),
        String::from(&quot;three&quot;),
    ];

    let result = largest(&amp;string_list);
    println!(&quot;The largest String is {}&quot;, result);
*/
}
</code></pre></pre>
<p>What happens if our array consists of <code>String</code>s?</p>
<p>Can we eliminate our <code>Copy</code> trait bound?</p>
<h1><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods" id="using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></h1>
<p>We can use a trait bound in an <code>impl</code> block to conditionally implement methods
for types that implement specific traits.</p>
<p>For example, we can implement <code>cmp_display</code> for <code>Pair&lt;T&gt;</code> if <code>T</code> is <code>Display</code>
and <code>PartialOrd</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods-1" id="using-trait-bounds-to-conditionally-implement-methods-1">Using Trait Bounds to Conditionally Implement Methods</a></h1>
<p>We can also conditionally implement a trait for any type that implements
another trait.</p>
<p>In the standard library, <code>ToString</code> is implemented for any type that is
<code>Display</code>.</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>We can call <code>to_string</code> on integers because they implement <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = 3.to_string();
#}</code></pre></pre>
<h1><a class="header" href="#recap-2" id="recap-2">Recap</a></h1>
<p><em>Traits</em> define shared behavior between types.</p>
<ul>
<li>We can implement a trait on a type as long as the trait or the type or both are
defined in the local crate.</li>
<li>We can provide default implementations of trait methods.</li>
</ul>
<p><em>Trait bounds</em> specify the behavior of generic type parameters.</p>
<ul>
<li><em>Where clauses</em> enable us to express complex trait bounds.</li>
<li>We can write functions that return types that implement traits using <code>impl Trait</code> as long as only one concrete type is ever returned.</li>
<li>We can conditionally implement methods for types that have generic type
parameters by placing trait bounds on the generic type parameters.</li>
</ul>
<p>Trait and trait bounds enable us to write code using generics that has specific
behavior.</p>
<p>In a dynamically typed language, we would get errors at compile time if we call
a method on a type that was not implemented.</p>
<p>In Rust, we check at compile time <em>and</em> don't suffer any performance penalties.</p>
<h1><a class="header" href="#workshop-1" id="workshop-1">Workshop</a></h1>
<p>Let dig deeper into some traits we've encountered before!</p>
<h1><a class="header" href="#question-1-1" id="question-1-1">Question 1</a></h1>
<p>Given a new type, <code>City</code>, how do we <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> print it?</p>
<pre><pre class="playpen"><code class="language-rust editable">struct City {
    name: String,
    state: String,
}

fn main() {
/*
    let x = City { name: String::from(&quot;Boston&quot;), state: String::from(&quot;MA&quot;) };
    println!(&quot;{:?}&quot;, x);
*/
}
</code></pre></pre>
<h1><a class="header" href="#answer-1-3" id="answer-1-3">Answer 1</a></h1>
<p>Although uncommon, we can manually implement the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> trait:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct City {
    name: String,
    state: String,
}

impl fmt::Debug for City {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;City {{ name: {:?}, state: {:?} }}&quot;, self.name, self.state)
    }
}

fn main() {
    let c = City { name: String::from(&quot;Boston&quot;), state: String::from(&quot;MA&quot;) };
    println!(&quot;{:?}&quot;, c);
}
</code></pre></pre>
<p>Normally, we use an <em>annotation</em> to derive the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> trait:</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct City {
    name: String,
    state: String,
}

fn main() {
    let c = City { name: String::from(&quot;Boston&quot;), state: String::from(&quot;MA&quot;) };
    println!(&quot;{:?}&quot;, c);
}
</code></pre></pre>
<h1><a class="header" href="#question-2-1" id="question-2-1">Question 2</a></h1>
<p>Given a new type, how do we <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> it?</p>
<pre><pre class="playpen"><code class="language-rust editable">struct City {
    name: String,
    state: String,
}

fn main() {
/*
    let x = City { name: String::from(&quot;Boston&quot;), state: String::from(&quot;MA&quot;) };
    println!(&quot;{}&quot;, x);
*/
}
</code></pre></pre>
<h1><a class="header" href="#answer-2-3" id="answer-2-3">Answer 2</a></h1>
<p>We manually implement the <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> trait for types since it is used
for user-facing output:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct City {
    name: String,
    state: String,
}

impl fmt::Display for City {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}, {}&quot;, self.name, self.state)
    }
}

fn main() {
    let x = City { name: String::from(&quot;Boston&quot;), state: String::from(&quot;MA&quot;) };
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<h1><a class="header" href="#question-3-1" id="question-3-1">Question 3</a></h1>
<p>How do we <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> and <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> the <code>City</code> type now?</p>
<pre><pre class="playpen"><code class="language-rust editable">enum Country {
    Canada,
    Mexico,
    UnitedStates,
}

struct City {
    name: String,
    state: String,
    country: Country,
}

fn main() {
/*
    let city = City {
        name: String::from(&quot;Boston&quot;),
        state: String::from(&quot;MA&quot;),
        country: Country::UnitedStates,
    };

    println!(&quot;Debug:   {:?}&quot;, city);
    println!(&quot;Display: {}&quot;, city);
*/
}
</code></pre></pre>
<h1><a class="header" href="#answer-3-2" id="answer-3-2">Answer 3</a></h1>
<p><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> can be conditionally derived if subtypes are <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>.</p>
<p>When manually implemented <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a>, we have options.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt;

#[derive(Debug)]
enum Country {
    Canada,
    Mexico,
    UnitedStates,
}

#[derive(Debug)]
struct City {
    name: String,
    state: String,
    country: Country,
}

impl fmt::Display for City {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}, {}, {:?}&quot;, self.name, self.state, self.country)
    }
}

fn main() {
    let city = City {
        name: String::from(&quot;Boston&quot;),
        state: String::from(&quot;MA&quot;),
        country: Country::UnitedStates,
    };

    println!(&quot;Debug:   {:?}&quot;, city);
    println!(&quot;Display: {}&quot;, city);
}
</code></pre></pre>
<h1><a class="header" href="#rust-workshop-part-ix" id="rust-workshop-part-ix">Rust Workshop: Part IX</a></h1>
<h2><a class="header" href="#lifetimes" id="lifetimes">Lifetimes</a></h2>
<h1><a class="header" href="#last-time-9" id="last-time-9">Last Time</a></h1>
<ul>
<li>Traits
<ul>
<li>Defining traits</li>
<li>Implementing traits</li>
<li>Default implementations</li>
</ul>
</li>
<li>Trait bounds
<ul>
<li>Traits as parameters</li>
<li>Returning types that implement traits</li>
<li>Conditionally implementing methods</li>
</ul>
</li>
<li>Workshop</li>
</ul>
<h1><a class="header" href="#today-8" id="today-8">Today</a></h1>
<ul>
<li>Dangling references</li>
<li>The borrow checker</li>
<li>Lifetimes
<ul>
<li>Generic lifetime parameters and functions</li>
<li>Generic lifetime parameters and structs</li>
<li>Lifetime elision</li>
<li>Generic lifetime parameters and methods</li>
<li>The static lifetime</li>
</ul>
</li>
<li>Recap</li>
<li>Workshop</li>
</ul>
<h1><a class="header" href="#quote-7" id="quote-7">Quote</a></h1>
<blockquote>
<p>Thanks for walking through the process.</p>
<p>Quite the mental exercise, some people do Sudoku, others solve borrow
puzzles!</p>
</blockquote>
<p> <a href="https://users.rust-lang.org/t/solved-channel-in-a-loop-in-a-thread-borrowed-value-does-not-live-long-enough/26733/9">Gambhiro on rust-users</a></p>
<h1><a class="header" href="#introduction-4" id="introduction-4">Introduction</a></h1>
<p>The term <em>lifetime</em> is synonymous with scope for which a <strong>reference</strong> is
valid.</p>
<p>Every reference in Rust has a lifetime.</p>
<p>Similar to types, Rust can infer the lifetimes of references in most cases.</p>
<p>In some situations however, we must annotate lifetimes when it is unclear how
lifetimes are related.</p>
<blockquote>
<p>The concept of lifetimes is somewhat different from tools in other
programming languages, arguably making lifetimes Rusts most distinctive
feature.</p>
</blockquote>
<h1><a class="header" href="#preventing-dangling-references" id="preventing-dangling-references">Preventing Dangling References</a></h1>
<p>The primary goal of lifetimes is to prevent dangling references.</p>
<p>Let's look at an example:</p>
<pre><code class="language-rust ignore">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><code>r</code> is assigned to a reference to <code>x</code>, but <code>x</code> &quot;does not live long enough&quot;:</p>
<pre><code class="language-plaintext">error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:9:14
   |
9  |         r = &amp;x;
   |              ^ borrowed value does not live long enough
10 |     }
   |     - `x` dropped here while still borrowed
...
13 | }
   | - borrowed value needs to live until here
</code></pre>
<p>How does Rust determine that this code is invalid? <strong>The Borrow Checker</strong>.</p>
<h1><a class="header" href="#the-borrow-checker" id="the-borrow-checker">The Borrow Checker</a></h1>
<p>The borrow checker is the part of the Rust compiler that compares scopes to
determine whether all borrows are valid.</p>
<p>Below, we've annotated the lifetimes, <code>'a</code> and <code>'b</code>, of the variables, <code>r</code> and
<code>x</code> respectively:</p>
<pre><code class="language-rust ignore">{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<p>Since <code>r</code> refers to memory with a lifetime <code>'b</code>, which has a <em>shorter</em> lifetime
than <code>'a</code>, this program is rejected.</p>
<p>Let's fix this example by extending the lifetime of <code>x</code>, <code>'b</code>.</p>
<pre><code class="language-plaintext">{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
</code></pre>
<p>This is <em>where</em> and <em>how</em> Rust analyzes lifetimes.</p>
<h1><a class="header" href="#generic-lifetimes-in-functions" id="generic-lifetimes-in-functions">Generic Lifetimes in Functions</a></h1>
<p>Let's consider the case where want to write a function that takes two string
slices and returns the longer slice.</p>
<p>We might use the <code>longest</code> function like this:</p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p>We want use slices, which are references, so the <code>longest</code> function does not
take ownership of the strings we wish to compare.</p>
<h1><a class="header" href="#generic-lifetimes-in-functions-1" id="generic-lifetimes-in-functions-1">Generic Lifetimes in Functions</a></h1>
<p>Let's implement the longest function:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p>Interestingly, this does not compile and returns this error message:</p>
<pre><code class="language-plaintext">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:4:33
  |
4 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>Rust can't tell if the reference being returned in <code>x</code> or <code>y</code> and we don't know
either!</p>
<p>We know that the we want the lifetime of the return value to be either the
lifetime <code>x</code> or <code>y</code>, but we won't know which one until the function is called
at runtime.</p>
<p>Also, the borrow checker does not know the relationship between the return
values either. Is the return always the lifetime of <code>x</code>, or maybe <code>y</code>, or maybe
it depends?</p>
<p>In this case, we need to manually define the relationship between the
references for the borrow checker.</p>
<h1><a class="header" href="#lifetime-annotation-syntax" id="lifetime-annotation-syntax">Lifetime Annotation Syntax</a></h1>
<p>Just like how functions can accept generic type parameters, functions can also
accept <em>generic lifetime parameters</em>.</p>
<p><em>Generic lifetime parameters</em> don't change how long references live, but rather
describe the relationship of multiple references.</p>
<p>Lifetime annotations always start with an apostrophe (<code>'</code>) and are usually all
lower case and very short, like generic types.</p>
<p>We place the lifetime annotation after the <code>&amp;</code> of a reference and use a space to
separate the annotation from the reference type.</p>
<p>Here are some examples:</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<h1><a class="header" href="#lifetime-annotations-in-function-signatures" id="lifetime-annotations-in-function-signatures">Lifetime Annotations in Function Signatures</a></h1>
<p>Now, let's fix our <code>longest</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>Like generic type parameters, we place our generic lifetime parameter <code>'a</code>
inside the angle brackets after the function name.</p>
<p>By attaching <code>'a</code> to the two function parameters, we're telling Rust that both
string slices must live <em>at least as long</em> as <code>'a</code>.</p>
<p>By attaching <code>'a</code> to the function return, we're telling Rust that the string
slice returned will live <em>at least as long</em> as <code>'a</code>.</p>
<p>These are the constraints we want to enforce. We have communicated to the
borrow checker that it <strong>must</strong> be enforced.</p>
<p>Lifetime annotations go in the function signature instead of the function body
since it very difficult for Rust to determine the lifetimes of the parameters
or return value on its own.</p>
<p>We must annotate the lifetimes manually.</p>
<h1><a class="header" href="#lifetime-annotations-in-function-signatures-1" id="lifetime-annotations-in-function-signatures-1">Lifetime Annotations in Function Signatures</a></h1>
<p>Let's inspect the lifetime constraints we have placed on the <code>longest</code>
function:</p>
<pre><pre class="playpen"><code class="language-rust"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p>The borrow checker approves of this since the lifetime of <code>string2</code> is at least
as long as the lifetime of <code>result</code>.</p>
<h1><a class="header" href="#lifetime-annotations-in-function-signatures-2" id="lifetime-annotations-in-function-signatures-2">Lifetime Annotations in Function Signatures</a></h1>
<p>What happens if we try to print out <code>result</code> in the outer scope?</p>
<pre><code class="language-rust ignore"># fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#     if x.len() &gt; y.len() {
#         x
#     } else {
#         y
#     }
# }
fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p>The borrow checker catches this!</p>
<pre><code class="language-plaintext">error[E0597]: `string2` does not live long enough
  --&gt; src/main.rs:13:44
   |
13 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ^^^^^^^ borrowed value does not live long enough
14 |     }
   |     - `string2` dropped here while still borrowed
15 |     println!(&quot;The longest string is {}&quot;, result);
16 | }
   | - borrowed value needs to live until here
</code></pre>
<p>The borrow checker tells us exactly where the lifetime of <code>string2</code> ends and
how the lifetime of <code>result</code> outlives it.</p>
<p><code>result</code> is not valid in the outer scope since <code>string2</code> is not!</p>
<h1><a class="header" href="#thinking-in-terms-of-lifetimes" id="thinking-in-terms-of-lifetimes">Thinking in Terms of Lifetimes</a></h1>
<p>The way you need to specify lifetime parameters depends on what your function
is doing.</p>
<p>If the <code>longest</code> function always returned the first parameter, we would omit
the lifetime on the second parameter:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
#}</code></pre></pre>
<p>The second parameter <code>y</code> does not influence <code>x</code> or the return value in any way.
We only relate the lifetime of <code>x</code>, <code>'a</code>, to the output parameter.</p>
<h1><a class="header" href="#thinking-in-terms-of-lifetimes-1" id="thinking-in-terms-of-lifetimes-1">Thinking in Terms of Lifetimes</a></h1>
<p>When returning a reference from a function, the lifetime parameter of the
return type must match the lifetime of one of the input parameters.</p>
<p>If the lifetime parameter of the return type does not match one of the
lifetimes of the input types, it must refer to a lifetime of a value created
within the function itself. This is dangling reference.</p>
<p>Consider this as an example:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Even though we've given the return type a lifetime parameter, this
implementation fails because the return lifetime is not related to any of the
input parameters.</p>
<pre><code class="language-plaintext">error[E0597]: `result` does not live long enough
 --&gt; src/main.rs:6:5
  |
6 |     result.as_str()
  |     ^^^^^^ borrowed value does not live long enough
7 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the function body at 4:12...
 --&gt; src/main.rs:4:12
  |
4 | fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
  |            ^^
</code></pre>
<p>The lifetime of <code>result</code> ends just as we want to return it from the function!
This is a dangling reference!</p>
<p>Ultimately, the lifetime syntax is about associating the lifetimes of the input
parameters to return values from functions. This fills in missing information
for the borrow checker to maintain memory safety.</p>
<h1><a class="header" href="#lifetime-annotations-in-struct-definitions" id="lifetime-annotations-in-struct-definitions">Lifetime Annotations in Struct Definitions</a></h1>
<p>It's possible for structs to hold references.</p>
<p>We need to add a lifetime parameter to every reference in the definition.</p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<p>The lifetime of <code>part</code> must outlive the lifetime of <code>ImportantExcerpt</code>!</p>
<h1><a class="header" href="#lifetime-elision" id="lifetime-elision">Lifetime Elision</a></h1>
<p>We don't need to annotate lifetime parameters in some situations:</p>
<pre><pre class="playpen"><code class="language-rust editable">// fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
</code></pre></pre>
<p>In the process of using the language, the Rust team found that programmers were
entering the same lifetime annotations over and over again in particular
situations.</p>
<p>The borrow checker <em>can infer</em> lifetimes in some situations.</p>
<p>It's possible that more deterministic patterns will emerge and fewer lifetime
annotations will be required.</p>
<h1><a class="header" href="#lifetime-elision-1" id="lifetime-elision-1">Lifetime Elision</a></h1>
<p>The patterns programmed into Rust's analysis of references are called the
<em>lifetime elision rules</em>.</p>
<p>There are three rules:</p>
<ol>
<li>
<p>Each parameter that is a reference gets its own lifetime parameter</p>
<ul>
<li>One lifetime parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code></li>
<li>Two lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code></li>
</ul>
</li>
<li>
<p>If there is exactly one input lifetime parameter, that lifetime is assigned
to all output lifetime parameters.</p>
<ul>
<li>For example: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code></li>
</ul>
</li>
<li>
<p>If there are multiple input lifetime parameters and one of them is <code>&amp;self</code>
or <code>&amp;mut self</code>, the lifetime of <code>self</code> is assigned to all output lifetime
parameters.</p>
</li>
</ol>
<h1><a class="header" href="#lifetime-annotations-in-method-definitions" id="lifetime-annotations-in-method-definitions">Lifetime Annotations in Method Definitions</a></h1>
<p>When we implement methods on a struct with lifetimes, the lifetimes could be
related to the struct fields or the method parameters and return values.</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code>
keyword and then used after the struct name.</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</code></pre>
<p>For method signatures inside the <code>impl</code> block, references might be tied to the
lifetime of references in the struct's fields, or they might be independent.</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
</code></pre>
<p>In the example above, we don't need to annotate the lifetimes because of the
first rule.</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
</code></pre>
<p>The first elision rule gives <code>&amp;self</code> and <code>&amp;str</code> separate lifetimes and the
third elision rule ties the lifetime of <code>&amp;self</code> to the return type lifetime.</p>
<pre><code class="language-rust ignore">    fn announce_and_return_part(&amp;'a self, announcement: &amp;str) -&gt; &amp;'a str {
</code></pre>
<h1><a class="header" href="#the-static-lifetime" id="the-static-lifetime">The Static Lifetime</a></h1>
<p>One special lifetime is the <code>'static</code> lifetime that represents the entire
duration of the program.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
#}</code></pre></pre>
<p>The text of this string is stored directly into the binary of the program.</p>
<p>The lifetime of <em>all</em> string literals is <code>'static</code>.</p>
<p>You might see the compiler suggest to you that a lifetime should be <code>'static</code>.
Often this is not the case and might be fixed a different way.</p>
<h1><a class="header" href="#generics-trait-bounds-and-lifetimes-together" id="generics-trait-bounds-and-lifetimes-together">Generics, Trait Bounds, and Lifetimes Together</a></h1>
<p>Let's tie everything together with this example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
#}</code></pre></pre>
<p>We're finding and returning the longest <code>&amp;str</code> and printing a type that can be
<code>Display</code>ed to stdout.</p>
<h1><a class="header" href="#recap-3" id="recap-3">Recap</a></h1>
<p>In the last three talks, we've introduced several topics related to generics:</p>
<ul>
<li><strong>Generic type parameters</strong> for removing duplication</li>
<li><strong>Traits</strong> for defining shared behavior</li>
<li><strong>Trait bounds</strong> for enhancing generic type parameters with behaviors</li>
<li><strong>Generic lifetime parameters</strong> for eliminating dangling references</li>
</ul>
<p>There's much more to learn on all of these topics, stay tuned!</p>
<h1><a class="header" href="#workshop-2" id="workshop-2">Workshop</a></h1>
<p>Let's look at some examples where we need to use lifetimes!</p>
<h1><a class="header" href="#question-1-2" id="question-1-2">Question 1</a></h1>
<p>For each example:</p>
<ul>
<li>Does this compile?</li>
<li>Annotate the lifetimes!</li>
</ul>
<pre><code class="language-rust ignore">fn last_word(s: &amp;str) -&gt; &amp;str {
#    let i = s.rfind(&quot; &quot;)
#        .map(|x| x + 1)
#        .unwrap_or(0);
#    &amp;s[i..]
    // -snip-
}
</code></pre>
<pre><code class="language-rust ignore">fn first_occurrence(s: &amp;str, substring: &amp;str) -&gt; &amp;str {
    // -snip-
#   s
}
</code></pre>
<pre><code class="language-rust ignore">fn first_two_occurrences(s: &amp;str, substring: &amp;str) -&gt; (&amp;str, &amp;str) {
    // -snip-
#   s
}
</code></pre>
<h1><a class="header" href="#answer-1-4" id="answer-1-4">Answer 1</a></h1>
<p>The <code>last_word</code> function compiles just fine:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// fn last_word(s: &amp;'a str) -&gt; &amp;'a str {
fn last_word(s: &amp;str) -&gt; &amp;str {
    // -snip-
#   s
}
#}</code></pre></pre>
<p>The original <code>first_occurrence</code> function did not compile. We need to add a
lifetime annotation <code>'a</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// fn first_occurrence(s: &amp;str, substring: &amp;str) -&gt; &amp;str {
fn first&lt;'a&gt;(s: &amp;'a str, substring: &amp;str) -&gt; &amp;'a str {
    // -snip-
#   s
}
#}</code></pre></pre>
<p>Similarly, the original <code>first_two_occurrences</code> function did not compile. We
need to add a lifetime annotation <code>'a</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_two_occurrences&lt;'a&gt;(s: &amp;'a str, substring: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
    // -snip-
#   (s, s)
}
#}</code></pre></pre>
<h1><a class="header" href="#question-2-2" id="question-2-2">Question 2</a></h1>
<p>Does if this compile? If not, how can we fix this?</p>
<pre><pre class="playpen"><code class="language-rust compile_fail editable">#[derive(Debug)]
struct Message {
    name: &amp;str,
    data: &amp;[u32],
}

impl Message {
    // Set the new name and return the old one
    fn update_name(&amp;mut self, name: &amp;str) -&gt; &amp;str {
        let old = self.name;
        self.name = name;
        old
    }

    // Deconstruct the message
    fn decompose(self) -&gt; (&amp;str, &amp;[u32]) {
        (self.name, self.data)
    }
}

fn main() {
    let name = &quot;numbers&quot;;
    let data = [3, 5, 1, 6, 2];

    let mut message = Message {
        name: &amp;name,
        data: &amp;data,
    };

    println!(&quot;original message: {:?}&quot;, message);
    println!(&quot;old name: {:?}&quot;, message.update_name(&quot;yolo&quot;));
    println!(&quot;updated message: {:?}&quot;, message);
    println!(&quot;decomposed: {:?}&quot;, message.decompose());
}
</code></pre></pre>
<h1><a class="header" href="#answer-2-4" id="answer-2-4">Answer 2</a></h1>
<p>Let's annotate the lifetime parameters:</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Message&lt;'a, 'b&gt; {
    name: &amp;'a str,
    data: &amp;'b [u32],
}

impl&lt;'a, 'b&gt; Message&lt;'a, 'b&gt; {
    // Set the new name and return the old one
    fn update_name(&amp;mut self, name: &amp;'a str) -&gt; &amp;str {
        let old = self.name;
        self.name = name;
        old
    }

    // Deconstruct the message
    fn decompose(self) -&gt; (&amp;'a str, &amp;'b [u32]) {
        (self.name, self.data)
    }
}

fn main() {
    let name = &quot;numbers&quot;;
    let data = [3, 5, 1, 6, 2];

    let mut message = Message {
        name: &amp;name,
        data: &amp;data,
    };

    println!(&quot;original message: {:?}&quot;, message);
    println!(&quot;old name: {:?}&quot;, message.update_name(&quot;yolo&quot;));
    println!(&quot;updated message: {:?}&quot;, message);
    println!(&quot;decomposed: {:?}&quot;, message.decompose());
}
</code></pre></pre>
<h1><a class="header" href="#question-3-2" id="question-3-2">Question 3</a></h1>
<p>Let's take another look at <code>serde</code>!</p>
<h2><a class="header" href="#a-hreflifetimesworkshopserdeserdea-deserializer-lifetimes" id="a-hreflifetimesworkshopserdeserdea-deserializer-lifetimes"><a href="lifetimes/workshop/serde"><code>serde</code></a> Deserializer Lifetimes</a></h2>
<pre><code class="language-rust ignore">#[derive(Deserialize)]
struct User&lt;'a&gt; {
    id: u32,
    name: &amp;'a str,
    screen_name: &amp;'a str,
    location: &amp;'a str,
}
</code></pre>
<blockquote>
<p>User struct above, that borrows string or byte array data from the string or
byte array holding the input. This avoids allocating memory to store a string
for each individual field and then copying string data out of the input over
to the newly allocated field. Rust guarantees that the input data outlives
the period during which the output data structure is in scope, meaning it is
impossible to have dangling pointer errors as a result of losing the input
data while the output data structure still refers to it.</p>
</blockquote>
<p>Specifically, the <code>Deserialize&lt;'de&gt;</code> lifetime records the constraints on how
long data borrowed by this type must be valid.</p>
<p>Let's look at an example of this:</p>
<pre><code class="language-rust ignore">use serde_derive; // 1.0.90
use serde_json; // 1.0.39

use serde_derive::Deserialize;

#[derive(Debug, Deserialize)]
struct User&lt;'a&gt; {
    id: u32,
    name: &amp;'a str,
    screen_name: &amp;'a str,
    location: &amp;'a str,
}

fn get_user() -&gt; User {
    let data = r#&quot;
        {
            &quot;id&quot;: 1,
            &quot;name&quot;: &quot;Ted Plummer&quot;,
            &quot;screen_name&quot;: &quot;Arthur&quot;,
            &quot;location&quot;: &quot;The Ocean&quot;
        }&quot;#;
    serde_json::from_str(data).unwrap()
}

fn main() {
    println!(&quot;{:?}&quot;, get_user());
}
</code></pre>
<p>Is this a compiler error? <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=08e1e0d2c910d2b5dd2554328386137f">Playpen</a></p>
<h1><a class="header" href="#answer-3-3" id="answer-3-3">Answer 3</a></h1>
<p>We need to provide a <code>'static</code> lifetime to the <code>User</code> return of the <code>get_user</code>
function.</p>
<pre><code class="language-rust ignore">use serde_derive; // 1.0.90
use serde_json; // 1.0.39

use serde_derive::Deserialize;

#[derive(Debug, Deserialize)]
struct User&lt;'a&gt; {
    id: u32,
    name: &amp;'a str,
    screen_name: &amp;'a str,
    location: &amp;'a str,
}

fn get_user() -&gt; User&lt;'static&gt; {
    let data = r#&quot;
        {
            &quot;id&quot;: 1,
            &quot;name&quot;: &quot;Ted Plummer&quot;,
            &quot;screen_name&quot;: &quot;Arthur&quot;,
            &quot;location&quot;: &quot;The Ocean&quot;
        }&quot;#;
    serde_json::from_str(data).unwrap()
}

fn main() {
    println!(&quot;{:?}&quot;, get_user());
}
</code></pre>
<h1><a class="header" href="#rust-workshop-part-x" id="rust-workshop-part-x">Rust Workshop: Part X</a></h1>
<h2><a class="header" href="#automated-testing" id="automated-testing">Automated Testing</a></h2>
<h1><a class="header" href="#last-time-10" id="last-time-10">Last Time</a></h1>
<ul>
<li>Dangling references</li>
<li>The borrow checker</li>
<li>Lifetimes
<ul>
<li>Generic lifetime parameters and functions</li>
<li>Generic lifetime parameters and structs</li>
<li>Lifetime elision</li>
<li>Generic lifetime parameters and methods</li>
<li>The static lifetime</li>
</ul>
</li>
<li>Recap</li>
<li>Workshop</li>
</ul>
<h1><a class="header" href="#today-9" id="today-9">Today</a></h1>
<ul>
<li>Test functions</li>
<li>Asserting in tests</li>
<li>Catching panics</li>
<li>Using <code>Result&lt;T, E&gt;</code> in tests</li>
<li>Running tests
<ul>
<li>Showing function output</li>
<li>Ignoring tests</li>
</ul>
</li>
<li>Unit tests</li>
<li>Integration tests</li>
<li>Workshop: Building a Library Crate</li>
</ul>
<h1><a class="header" href="#quote-8" id="quote-8">Quote</a></h1>
<blockquote>
<p>We put in a lot of work to make upgrades painless; for example, we run a tool
(called <a href="https://github.com/rust-lang-nursery/crater">crater</a>) before each Rust release that downloads every
package on crates.io and attempts to build their code and run their tests.</p>
</blockquote>
<p> <a href="https://blog.rust-lang.org/2018/07/27/what-is-rust-2018.html">Rust Blog: What is Rust 2018</a>.</p>
<h1><a class="header" href="#introduction-5" id="introduction-5">Introduction</a></h1>
<p>Rust's type system helps us enormously with program correctness.</p>
<p>For example, we can't make type confusion errors like in C.</p>
<p>The type system cannot prevent all bugs however. Our program can suffer
from a logical mistake for instance.</p>
<p>To prevent these issues in practice, Rust has a builtin unit, integration and
performance testing framework to make it easy for you test your code in
practice!</p>
<h1><a class="header" href="#anatomy-of-a-test-function" id="anatomy-of-a-test-function">Anatomy of a Test Function</a></h1>
<p>When we create a new library crate with <code>cargo</code> an sample test is generated.</p>
<pre><code class="language-sh">$ cargo new autotest  --lib
    Created library `autotest` package
</code></pre>
<p>In <code>src/lib.rs</code>, we find a test called <code>it_works</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>Above, we need to specify which functions are tests using the <code>#[test]</code>
attribute for the functions since there could be private functions in the
<code>tests</code> module.</p>
<p>If we run <code>cargo test</code> on our crate, we get:</p>
<pre><code class="language-plaintext">running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests autotest

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Although we only have a single test here, we can have multiple test functions
in the <code>tests</code> module.</p>
<h1><a class="header" href="#asserting-results" id="asserting-results">Asserting Results</a></h1>
<p>We can use the regular <code>assert!</code> macro to test boolean results:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn first_factor(x: u64) -&gt; u64 {
#     if x % 2 == 0 {
#         return 2;
#     }
#
#     for n in (3..).step_by(2).take_while(|m| m * m &lt;= x) {
#         if x % n == 0 {
#             return n;
#         }
#     }
#
#     return x;
# }
#
fn is_prime(n: u64) -&gt; bool {
#    if n &lt;= 1 {
#        return false;
#    }
#    first_factor(n) == n
    // --snip--
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_seven_prime() {
        assert!(is_prime(7));
    }

    #[test]
    fn is_ten_prime() {
        assert!(is_prime(10));
    }
}
#}</code></pre></pre>
<p>We typically add a relative <code>use super::*;</code> to test functions from the parent
module in the same file.</p>
<p>If we run this, we get a failure since ten is not prime. Rust points us at the
failed assertion.</p>
<pre><code class="language-plaintext">running 2 tests
test tests::is_seven_prime ... ok
test tests::is_ten_prime ... FAILED

failures:

---- tests::is_ten_prime stdout ----
thread 'tests::is_ten_prime' panicked at 'assertion failed: is_prime(10)', src/lib.rs:34:9
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<h1><a class="header" href="#testing-equality" id="testing-equality">Testing Equality</a></h1>
<p>We can also use the <code>assert_eq!</code> and <code>assert_nq!</code> to test equality:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn first_factor(x: u64) -&gt; u64 {
#     if x % 2 == 0 {
#         return 2;
#     }
#
#     for n in (3..).step_by(2).take_while(|m| m * m &lt;= x) {
#         if x % n == 0 {
#             return n;
#         }
#     }
#
#     return x;
# }
#
fn is_prime(n: u64) -&gt; bool {
#    if n &lt;= 1 {
#        return false;
#    }
#    first_factor(n) == n
    // --snip--
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_seven_prime() {
        assert_eq!(true, is_prime(7));
    }

    #[test]
    fn is_ten_prime() {
        assert_eq!(true, is_prime(10));
    }
}
#}</code></pre></pre>
<p>Let's check out the error message now:</p>
<pre><code class="language-plaintext">running 2 tests
test tests::is_seven_prime ... ok
test tests::is_ten_prime ... FAILED

failures:

---- tests::is_ten_prime stdout ----
thread 'tests::is_ten_prime' panicked at 'assertion failed: `(left == right)`
    left: `true`,
   right: `false`', src/lib.rs:34:9
   note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Equivalence assertions give us more information than regular <code>assert</code>s.</p>
<h1><a class="header" href="#custom-failure-messages" id="custom-failure-messages">Custom Failure Messages</a></h1>
<p>Sometimes, we may want to print custom error messages on failures:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_factor(x: u64) -&gt; u64 {
#     if x % 2 == 0 {
#         return 2;
#     }
#
#     for n in (3..).step_by(2).take_while(|m| m * m &lt;= x) {
#         if x % n == 0 {
#             return n;
#         }
#     }
#
#     return x;
    // --snip--
}
#
# fn is_prime(n: u64) -&gt; bool {
#    if n &lt;= 1 {
#        return false;
#    }
#    first_factor(n) == n
#     // --snip--
# }

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn first_factor_21() {
        let factor = first_factor(21);
        assert!(factor == 7, &quot;The first factor was not 7, but {}&quot;, factor);
    }
}
#}</code></pre></pre>
<p>We can produce even more informative error messages now.</p>
<pre><code class="language-plaintext">running 1 test
test tests::first_factor_21 ... FAILED

failures:

---- tests::first_factor_21 stdout ----
thread 'tests::first_factor_21' panicked at 'The first factor was not 7, but 3', src/lib.rs:32:9
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<h1><a class="header" href="#checking-for-panics" id="checking-for-panics">Checking for Panics</a></h1>
<p>Occasionally, we want to ensure that a function will panic in a test when given
certain inputs.</p>
<p>We can use the <code>#[should_panic]</code> attribute for these situations.</p>
<p>We can even add an attribute parameter to <code>#[should_panic]</code> called <code>expected</code>
where we can ensure that the correct panic string was produced.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn first_factor(x: u64) -&gt; u64 {
#     if x % 2 == 0 {
#         return 2;
#     }
#
#     for n in (3..).step_by(2).take_while(|m| m * m &lt;= x) {
#         if x % n == 0 {
#             return n;
#         }
#     }
#
#     return x;
# }
#
fn is_prime(n: i64) -&gt; bool {
    if n &lt; 0 {
        panic!(&quot;Natural numbers only please!&quot;);
    }
#
#    if n &lt;= 1 {
#        return false;
#    }
#    let n = n as u64;
#    first_factor(n) == n
    // --snip--
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn is_seven_prime() {
        assert!(is_prime(7));
    }

    #[test]
    #[should_panic]
    fn is_negative_ten_prime() {
        assert!(is_prime(-10));
    }

    #[test]
    #[should_panic(expected = &quot;Positive integers only please!&quot;)]
    fn is_negative_twenty_prime() {
        assert!(is_prime(-20));
    }
}
#}</code></pre></pre>
<p>The panics were captured, but one test failed because a panic string mismatch.</p>
<pre><code class="language-plaintext">running 3 tests
test tests::is_seven_prime ... ok
test tests::is_negative_ten_prime ... ok
test tests::is_negative_twenty_prime ... FAILED

failures:

---- tests::is_negative_twenty_prime stdout ----
thread 'tests::is_negative_twenty_prime' panicked at 'Natural numbers only please!', src/lib.rs:17:9
note: Panic did not include expected string 'Positive integers only please'
</code></pre>
<h1><a class="header" href="#using-result-in-tests" id="using-result-in-tests">Using Result in Tests</a></h1>
<p>We can also write tests that return a <code>Result&lt;T, E&gt;</code>.</p>
<p>Let's modify the <code>it_works</code> test slightly:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
#}</code></pre></pre>
<p>Two things to note:</p>
<ol>
<li>We can't use the <code>#[should_panic]</code> annotation on test that return
<code>Result&lt;T, E&gt;</code>. We should return and <code>Err</code> instead.</li>
<li>We can use the <code>?</code> operator for convenience.</li>
</ol>
<h1><a class="header" href="#running-tests" id="running-tests">Running Tests</a></h1>
<p>We can send options to <code>cargo test</code> by specifying flags before the <code>--</code>. Flags
after <code>--</code> are sent to the test binary directly.</p>
<p>By default, tests are run in parallel, we can disable this like so:</p>
<pre><code class="language-sh">$ cargo test -- --test-threads=1
</code></pre>
<p><code>cargo test</code> will run all tests in our crate by default.</p>
<p>We can test an individual test function by calling the name directly:</p>
<pre><code class="language-sh">$ cargo test is_seven_prime
</code></pre>
<p>We can test all functions that start with a particular string. Based on our
previous examples, lets run all tests that start with <code>is_prime</code>:</p>
<pre><code class="language-sh">$ cargo test is_prime
</code></pre>
<h1><a class="header" href="#showing-function-output" id="showing-function-output">Showing Function Output</a></h1>
<p><code>cargo test</code> captures standard output.</p>
<p>Anything we print using <code>println!</code> for example, will not be displayed when
running tests.</p>
<p>We can disable standard output capture:</p>
<pre><code class="language-sh">$ cargo test -- --nocapture
</code></pre>
<h1><a class="header" href="#ignoring-tests" id="ignoring-tests">Ignoring Tests</a></h1>
<p>There is another attribute use to ignore expensive or long tests: <code>#[ignore]</code>.</p>
<pre><code class="language-rust ignore">#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
</code></pre>
<p>We can run these tests by passing <code>--ignored</code></p>
<pre><code class="language-sh">$ cargo test -- --ignored
</code></pre>
<h1><a class="header" href="#unit-tests" id="unit-tests">Unit Tests</a></h1>
<p>All tests we have seen so far are considered unit tests in the Rust ecosystem.</p>
<blockquote>
<p>Unit tests in Rust live in the <strong>same file</strong> as the code they test.</p>
</blockquote>
<p>The <code>#[cfg(test)]</code> configuration attribute ensures that test code is only
compiled when <code>cargo test</code> is called <em>not</em> <code>cargo build</code> or <code>cargo run</code>.</p>
<p>Unit tests in Rust give us the ability to test internal function that are
not exposed in a public crate API:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#integration-tests" id="integration-tests">Integration Tests</a></h1>
<p>Integration tests in Rust test code just as an external user would.</p>
<p>These tests can only interact with the external API exposed by the library
crate.</p>
<p>Integration tests in Rust live in the <code>tests</code> directory (next to <code>src</code>):</p>
<pre><code class="language-rust ignore">// Bring our crate into scope
use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>We no longer need <code>#[cfg(test)]</code>. Instead, Cargo will compile each file in the
<code>tests</code> directory as a separate test crate.</p>
<p>There is one exception to this: files in subdirectories of the <code>tests</code> directory
do not get compiled as separate crates or have sections in their test output.</p>
<p>For example, <code>tests/common/mod.rs</code> will be ignored.</p>
<h1><a class="header" href="#mocking" id="mocking">Mocking</a></h1>
<p>Mocking is a way of isolating code under test by replacing dependencies with
implementations that emulate real functionality.</p>
<p>This is quite useful when dependencies are difficult to incorporate into a unit
testing framework.</p>
<p>There are <em>many</em> Rust crates that provide mocking currently with no clear
community preference yet.</p>
<p>You can read more about the different mocking frameworks here:
<a href="https://asomers.github.io/mock_shootout/">mock_shootout</a>.</p>
<h1><a class="header" href="#workshop-3" id="workshop-3">Workshop</a></h1>
<p>We're going to build a library crate to test out some of Rust's testing
features!</p>
<h1><a class="header" href="#creating-a-library-crate" id="creating-a-library-crate">Creating a Library Crate</a></h1>
<p>Let's create a new library crate:</p>
<pre><code class="language-sh">$ cargo new primes-workshop --lib
$ cd primes-workshop
</code></pre>
<p>We should now have the follow directory structure</p>
<pre><code class="language-plaintext"> Cargo.toml
 src
     lib.rs
</code></pre>
<h1><a class="header" href="#adding-functionality" id="adding-functionality">Adding Functionality</a></h1>
<p>We're going to have our crate expose a single public function, <code>is_prime</code>, that
determines if an integer is prime or not.</p>
<p>For convenience, here's a naive implementation that we'll use:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn first_factor(x: u64) -&gt; u64 {
    if x % 2 == 0 {
        return 2;
    }

    // From 3 to x, stepping by 2, check if n is a factor of x.
    for n in (3..).step_by(2).take_while(|m| *m &lt;= x) {
        if x % n == 0 {
            return n;
        }
    }

    return x;
}

// Returns true if the number is prime.
pub fn is_prime(n: u64) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }

    first_factor(n) == n
}
#}</code></pre></pre>
<h1><a class="header" href="#unit-testing-is_prime" id="unit-testing-is_prime">Unit Testing <code>is_prime</code></a></h1>
<p>How might we go about adding unit tests to <code>is_prime</code>?</p>
<pre><pre class="playpen"><code class="language-rust editable">fn first_factor(x: u64) -&gt; u64 {
    if x % 2 == 0 {
        return 2;
    }

		// From 3 to x, stepping by 2, check if n is a factor of x.
    for n in (3..).step_by(2).take_while(|m| *m &lt;= x) {
        if x % n == 0 {
            return n;
        }
    }

    return x;
}

// Returns true if the number is prime.
pub fn is_prime(n: u64) -&gt; bool {
    if n &lt;= 1 {
        return false;
    }

    first_factor(n) == n
}
</code></pre></pre>
<h1><a class="header" href="#integration-testing-is_prime" id="integration-testing-is_prime">Integration Testing <code>is_prime</code></a></h1>
<p>How might we go about adding integration tests to <code>is_prime</code>?</p>
<h1><a class="header" href="#benchmark-testing" id="benchmark-testing">Benchmark Testing</a></h1>
<p>Cargo supports another testing based command called <code>cargo bench</code>.</p>
<p>Unfortunately, the default bench testing framework Cargo use is only available
on nightly compiler.</p>
<p>A bench test in Rust looks something like this:</p>
<pre><code class="language-rust ignore">#![feature(test)]

extern crate test;

pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &amp;mut Bencher) {
        b.iter(|| add_two(2));
    }
}
</code></pre>
<h1><a class="header" href="#introducing-criterionrs-a-hrefhttpscratesiocratescriterionimg-srchttpsimgshieldsiocratesvcriterionsvg-altlatest-version-a" id="introducing-criterionrs-a-hrefhttpscratesiocratescriterionimg-srchttpsimgshieldsiocratesvcriterionsvg-altlatest-version-a">Introducing <code>criterion.rs</code> <a href="https://crates.io/crates/criterion"><img src="https://img.shields.io/crates/v/criterion.svg" alt="Latest Version" /></a></a></h1>
<p>If we're looking to run benchmark test using the stable compiler, we might want
to consider using a statistical based benchmarking framework like
<code>criterion.rs</code>.</p>
<blockquote>
<p>Criterion.rs helps you write fast code by detecting and measuring performance
improvements or regressions, even small ones, quickly and accurately. You can
optimize with confidence, knowing how each change affects the performance of
your code.</p>
</blockquote>
<h1><a class="header" href="#setting-up-criterionrs" id="setting-up-criterionrs">Setting up <code>criterion.rs</code></a></h1>
<p>We should add <code>criterion</code> as a dependency when <em>running tests only</em>.</p>
<pre><code class="language-toml">[dev-dependencies]
criterion = &quot;0.2&quot;

[[bench]]
name = &quot;is_prime&quot;
harness = false
</code></pre>
<p>The <code>[bench]</code> section defines one benchmark test <code>is_prime</code> that uses a custom
test harness.</p>
<h1><a class="header" href="#setting-up-criterionrs-1" id="setting-up-criterionrs-1">Setting up <code>criterion.rs</code></a></h1>
<p>We should also create an <code>is_prime</code> benchmark file in the <code>benches</code> directory.</p>
<p>In <code>benches/is_prime.rs</code>:</p>
<pre><code class="language-rust ignore">#[macro_use]
extern crate criterion;

use criterion::Criterion;
use criterion::black_box;

use primes_workshop;

fn my_is_prime_benchmark(c: &amp;mut Criterion) {
    c.bench_function(&quot;primes_workshop::is_prime 999983&quot;, |b| b.iter(||
        primes_workshop::is_prime(black_box(999983))
    ));
}

criterion_group!(benches, my_is_prime_benchmark);
criterion_main!(benches);
</code></pre>
<h1><a class="header" href="#comparing-benchmarks-of-is_prime" id="comparing-benchmarks-of-is_prime">Comparing Benchmarks of <code>is_prime</code></a></h1>
<p>There are two other <code>is_prime</code> functions we should compare against:</p>
<ul>
<li><a href="https://docs.rs/primes/0.2.3/primes/fn.is_prime.html">primes</a></li>
<li><a href="https://docs.rs/primal/0.2.3/primal/fn.is_prime.html">primal</a></li>
</ul>
<p>How can we use <code>criterion</code> to compare the performance of our <code>is_prime</code>
function to these crates?</p>
<p>What do you notice?</p>
<h1><a class="header" href="#rust-workshop-part-xi" id="rust-workshop-part-xi">Rust Workshop: Part XI</a></h1>
<h2><a class="header" href="#closures" id="closures">Closures</a></h2>
<h1><a class="header" href="#last-time-11" id="last-time-11">Last Time</a></h1>
<ul>
<li>Test functions</li>
<li>Asserting in tests</li>
<li>Catching panics</li>
<li>Using <code>Result&lt;T, E&gt;</code> in tests</li>
<li>Running tests
<ul>
<li>Showing function output</li>
<li>Ignoring tests</li>
</ul>
</li>
<li>Unit tests</li>
<li>Integration tests</li>
<li>Workshop: Building a Library Crate</li>
</ul>
<h1><a class="header" href="#today-10" id="today-10">Today</a></h1>
<ul>
<li>Closures
<ul>
<li>Abstracting behavior</li>
<li>Generic parameters</li>
<li>Capturing the environment</li>
<li>The <code>Fn</code> Traits</li>
<li>Move closures</li>
</ul>
</li>
<li>Workshop: Closure exercises</li>
</ul>
<h1><a class="header" href="#quote-9" id="quote-9">Quote</a></h1>
<blockquote>
<p>Closures make functional style possible, and Rusts implementation makes this
efficient as possible. There is a lot less explicit looping needed, and you
(generally) dont have to worry about the performance implications of avoiding
loops.</p>
</blockquote>
<p> <a href="https://stevedonovan.github.io/rustifications/2018/08/18/rust-closures-are-hard.html">Steve Donovan</a></p>
<h1><a class="header" href="#introduction-6" id="introduction-6">Introduction</a></h1>
<p>Rust is significantly influenced by <em>functional programming</em>.</p>
<p>Specifically, <em>function programming</em> influences in Rust includes passing
functions as arguments, returning functions from other functions and assigning
functions to variables.</p>
<p>We're going to discuss two major topics:</p>
<ul>
<li><em>Closures</em>: a function-like construct you can store in a variable</li>
<li><em>Iterators</em>: a way of processing a series of elements</li>
</ul>
<h1><a class="header" href="#what-are-closures" id="what-are-closures">What <em>Are</em> Closures?</a></h1>
<p>In general, closures are a record storing a function together with an environment.</p>
<p>Unlike a function, a closure allows access to <em>captured variables</em> through the
closure's copies of their values or references.</p>
<p>Here's a short closure example in Python:</p>
<pre><code class="language-py">def f(x):
    def g(y):
        return x + y  # `x` is captued from the outer scope
    return g  # Return a closure

def h(x):
    return lambda y: x + y  # Return a closure

# Assigning specific closures to variables.
a = f(1)
b = h(1)

# Using the closures stored in variables.
assert a(5) == 6
assert b(5) == 6

# Using closures without binding them to variables first.
assert f(1)(5) == 6  # f(1) is the closure.
assert h(1)(5) == 6  # h(1) is the closure.
</code></pre>
<h1><a class="header" href="#c-function-pointers" id="c-function-pointers">C Function Pointers</a></h1>
<p>C does not have closures,<sup class="footnote-reference"><a href="#1">1</a></sup> but function pointers can provide something similar.</p>
<p>Using function pointers, we can implement closures:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;

typedef struct sClosure sClosure;

typedef void* (*tFunction)(void *env, void *args);

struct sClosure {
    tFunction fn;
    void *env;
};

sClosure build_closure(tFunction fn, void *env) {
    sClosure c = {
        .fn = fn,
        .env = env,
    };
    return c;
}

void* call_closure(sClosure *c, void *args) {
    return c-&gt;fn(c-&gt;env, args);
}

// This function adds two integers together!
void* g(void *env, void *args) {
    return (void *) (*(long *) env) + (*(long *) args);
}

// This function returns a closure
sClosure f(void *env) {
    return build_closure(&amp;g, env);
}

void main() {
    long x = 1;
    sClosure a = f(&amp;x);

    long arg = 5;
    long result = (long) call_closure(&amp;a, &amp;arg);
    assert(6 == result);
}
</code></pre>
<p>Quite unsafe and verbose!</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>There are C libraries that provide closure like constructs. GNU
<a href="closures/libffcall">libffcall</a> provides closures with variable arguments as first-class
C functions. Apple also has a non-standard C language extension called
<a href="closures/blocks">blocks</a> to provide closures.</p>
</div>
<h1><a class="header" href="#abstracting-behavior" id="abstracting-behavior">Abstracting Behavior</a></h1>
<p>Consider this example of running a function that takes a long (several seconds)
time to run:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
#}</code></pre></pre>
<p>Additionally, we use our expensive function when <code>generating_workouts</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
#     println!(&quot;calculating slowly...&quot;);
#     thread::sleep(Duration::from_secs(2));
#     intensity
# }
#
fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}

fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#abstracting-behavior-1" id="abstracting-behavior-1">Abstracting Behavior</a></h1>
<p>We can refactor the <code>generate_workout</code> function to only call
<code>simulated_expensive_calculation</code> once.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
# fn simulated_expensive_calculation(num: u32) -&gt; u32 {
#    println!(&quot;calculating slowly...&quot;);
#    thread::sleep(Duration::from_secs(2));
#    num
# }
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
#}</code></pre></pre>
<p>Now however, we always call the <code>simulated_expensive_calculation</code> function
regardless of whether we use the result.</p>
<h1><a class="header" href="#abstracting-behavior-2" id="abstracting-behavior-2">Abstracting Behavior</a></h1>
<p>Instead of calling a separate function every time, we can store the
<code>simulated_expensive_calculation</code>  in a <em>closure</em>:</p>
<pre><code class="language-rust ignore"># use std::thread;
# use std::time::Duration;
#
let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
</code></pre>
<p>We can then use our closure in the <code>generate_workout</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#type-inference-and-annotation" id="type-inference-and-annotation">Type Inference and Annotation</a></h1>
<p>Closures do not require you to annotate the types of the parameters like <code>fn</code>
functions.</p>
<p>Let's compare functions to closures:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }   // Function
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };  // Annotated closure
let add_one_v3 = |x|             { x + 1 };  // Closure with braces
let add_one_v4 = |x|               x + 1  ;  // Closure without braces
</code></pre>
<p>The compiler infers the types of the closure parameters based on the usage:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">
# #![allow(unused_variables)]
#fn main() {
let sample_closure = |x| x;

let s = sample_closure(String::from(&quot;hello&quot;));
let n = sample_closure(5);
#}</code></pre></pre>
<h1><a class="header" href="#storing-closures-using-generic-parameters" id="storing-closures-using-generic-parameters">Storing Closures using Generic Parameters</a></h1>
<p>One technique for mitigating the runtime affects of expensive functions is to
use memory to store results. In otherwords, use a cache.</p>
<p>We can have a struct hold the result as well as the closure by using a <code>Fn</code>
generic trait bound:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
#}</code></pre></pre>
<p>The <code>Cacher</code> struct holds a closure <code>T</code> that has one <code>u32</code> argument and a
return value of <code>u32</code>.</p>
<h1><a class="header" href="#storing-closures-using-generic-parameters-1" id="storing-closures-using-generic-parameters-1">Storing Closures using Generic Parameters</a></h1>
<p>Let's implement <code>Cacher</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#storing-closures-using-generic-parameters-2" id="storing-closures-using-generic-parameters-2">Storing Closures using Generic Parameters</a></h1>
<p>Finally, let's update the <code>generate_workout</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     calculation: T,
#     value: Option&lt;u32&gt;,
# }
#
# impl&lt;T&gt; Cacher&lt;T&gt;
#     where T: Fn(u32) -&gt; u32
# {
#     fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
#         Cacher {
#             calculation,
#             value: None,
#         }
#     }
#
#     fn value(&amp;mut self, arg: u32) -&gt; u32 {
#         match self.value {
#             Some(v) =&gt; v,
#             None =&gt; {
#                 let v = (self.calculation)(arg);
#                 self.value = Some(v);
#                 v
#             },
#         }
#     }
# }
#
# use std::thread;
# use std::time::Duration;
#
fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#capturing-the-environment" id="capturing-the-environment">Capturing the Environment</a></h1>
<p>So far, we've only used closures as inline anonymous functions.</p>
<p>Unlike functions, closures can also capture their environment and access
variables from the scope in which they are defined.</p>
<p>For example, <code>x</code> is captured in the example below:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p>If we try to use a function instead, we run into issues:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<h1><a class="header" href="#capturing-the-environment-1" id="capturing-the-environment-1">Capturing the Environment</a></h1>
<p>When a closure captures a value from its environment it uses memory to store
the values for use in the closure body.</p>
<p>As a result, closures incur some memory overhead while functions, which never
capture their environments, do not.</p>
<h1><a class="header" href="#the-fn-traits" id="the-fn-traits">The <code>Fn</code> Traits</a></h1>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably.</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known
as the closures environment. To consume the captured variables, the closure
must take ownership of these variables and move them into the closure when it
is defined. The <code>Once</code> part of the name represents the fact that the closure
cant take ownership of the same variables more than once, so it can be called
only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
<h1><a class="header" href="#the-fn-traits-1" id="the-fn-traits-1">The <code>Fn</code> Traits</a></h1>
<p>When a closure is created, Rust infers which trait to use based on how the
closure uses the values from the environment.</p>
<ul>
<li>All closures implement <code>FnOnce</code>.</li>
<li>Closures that don't move the captured variables also implement <code>FnMut</code>.</li>
<li>Closures that don't need mutable access to the captured variables also
implement <code>Fn</code>.</li>
</ul>
<p>In other words, <code>FnOnce</code> is a super trait of <code>FnMut</code> and <code>FnMut</code> is a super
trait of <code>Fn</code>.</p>
<p>For example, the <code>equal_to_x</code> closure only borrows <code>x</code> immutably from the
environment and therefore has the <code>Fn</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<h1><a class="header" href="#move-closures" id="move-closures">Move Closures</a></h1>
<p>Closures can be forced to take ownership of their environment by using the
<code>move</code> keyword.</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><code>move</code> closures are useful when passing a closure to a new thread so data is
owned by the new thread.  We'll revisit <code>move</code> when we talk about concurrency.</p>
<h1><a class="header" href="#recap-4" id="recap-4">Recap</a></h1>
<p>Closures...</p>
<ul>
<li>Represent functions that can be stored in variables</li>
<li>Can be a generic type parameter using a special syntax</li>
<li>Automatically implement a set of <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code></li>
<li>Can be marked <code>move</code> to force them to take ownership of their environment</li>
</ul>
<h1><a class="header" href="#workshop-4" id="workshop-4">Workshop</a></h1>
<p>Let's look at some examples of closures!</p>
<h1><a class="header" href="#question-1-3" id="question-1-3">Question 1</a></h1>
<p>Do these compile and why? If not, how can we fix them?</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let hello = &quot;hello&quot;;
    let print = |s| println!(&quot;{} {}&quot;, hello, s);
    print(&quot;world&quot;);
    print(&quot;ten&quot;);
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let hello = &quot;hello&quot;;
    let print = |s| println!(&quot;{} {}&quot;, hello, s);
    print(&quot;world&quot;);
    print(10);
}
</code></pre></pre>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let hello = String::from(&quot;hello&quot;);
    let mutate = |s| s.truncate(4);
    mutate(hello);
    println!(&quot;{}&quot;, hello);
}
</code></pre></pre>
<h1><a class="header" href="#answer-1-5" id="answer-1-5">Answer 1</a></h1>
<p>The last code block is a tricky. Here's the original code:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let hello = String::from(&quot;hello&quot;);
    let mutate = |s| s.truncate(4);
    mutate(hello);
    println!(&quot;{}&quot;, hello);
}
</code></pre></pre>
<p>We need to add a type annotations to the closure since the type is unclear:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let hello = String::from(&quot;hello&quot;);
    let mutate = |s: String| s.truncate(4);
    mutate(hello);
    println!(&quot;{}&quot;, hello);
}
</code></pre></pre>
<p>Finally, we need to make <code>hello</code> and the closure parameter mutable:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut hello = String::from(&quot;hello&quot;);
    let mutate = |s: &amp;mut String| s.truncate(4);
    mutate(&amp;mut hello);
    println!(&quot;{}&quot;, hello);
}
</code></pre></pre>
<h1><a class="header" href="#question-2-3" id="question-2-3">Question 2</a></h1>
<p>Refactor the code below by creating a new function called <code>mutate_hello</code> that
mutates the <code>String</code> hello and returns the newly mutated <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut hello = String::from(&quot;hello&quot;);
    let mutate = |s: &amp;mut String| s.truncate(4);
    mutate(&amp;mut hello);
    println!(&quot;{}&quot;, hello);
}
</code></pre></pre>
<h1><a class="header" href="#answer-2-5" id="answer-2-5">Answer 2</a></h1>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let hello = mutate_hello(|s| {
        s.truncate(4);
    });
    println!(&quot;{}&quot;, hello);
}

fn mutate_hello&lt;F: Fn(&amp;mut String) -&gt; ()&gt;(f: F) -&gt; String {
    let mut hello = String::from(&quot;hello&quot;);
    f(&amp;mut hello);
    hello
}
</code></pre></pre>
<h1><a class="header" href="#rust-workshop-part-xii" id="rust-workshop-part-xii">Rust Workshop: Part XII</a></h1>
<h2><a class="header" href="#iterators" id="iterators">Iterators</a></h2>
<h1><a class="header" href="#last-time-12" id="last-time-12">Last Time</a></h1>
<h1><a class="header" href="#quote-10" id="quote-10">Quote</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
